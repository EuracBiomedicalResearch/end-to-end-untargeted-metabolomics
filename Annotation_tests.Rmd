---
title: "Aligning MS2 data to MS1"
author: "Philippine Louail"
date: "2024-01-31"
output: html_document
---

# General layout/discussion

Two possible approaches. Not clear which one would be better for the
end-to-end. Depends mostly what would be easier to describe.

a) try to annotate all features from run 1.
  Advantage:
  - have a more *complete* annotation of the data. something that might be used
    for a *real* data analysis.
  Disadvantage:
  - MS2 data from run 2 not really designed for that (no DDA, but inclusion list
    used).
  - will have only few matches, need a lot of filtering.
  - needs a general/global evaluation and visualization of results.

b) annotate significant features from run 1.
  Advantage:
  - MS2 data was generated mostly for these features.
  - easier to describe/understand: few features, can check results individually.
  - in the end, analysts will focus on these features anyway.
  Disadvantage:
  - only very few matches.
  - we would need to describe how that could be done for the full data set too.


```{r packages used, message=FALSE, warning=FALSE}
library(MsExperiment)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(MetaboCoreUtils)
library(MetaboAnnotation)
```

```{r}
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(2)))
} else {
    register(bpstart(SnowParam(2)))
}
```
Evaluate shift between run1 and run2:

# Annotate features from run1 to database based on m/z only

Annotating significant features to compounds based on their *m/z* value and
potential/likely ions they might represent.

```{r}
library(SummarizedExperiment)
load("Sum_Exp_afterDA.RData")

#' load reference data
library(AnnotationHub)
library(CompoundDb)
ah <- AnnotationHub()
query(ah, "MassBank")
mb <- ah[["AH116166"]]

library(MetaboAnnotation)
p <- Mass2MzParam(adducts = c("[M+H]+", "[M+Na]+", "[M+H-NH3]+"),
                  tolerance = 0, ppm = 5)

cmps <- compounds(mb, columns = c("compound_id", "name", "formula", "exactmass"))

#' annotating just the significant features
rowData(res)$feature_id <- rownames(rowData(res))
res_sig <- res[rowData(res)$significant.CVD, ]
mtch <- matchValues(res_sig, cmps, param = p, mzColname = "mzmed")
mtch
```

Evaluating for each significant feature the hits to the database.

```{r}
mtch_res <- matchedData(mtch, c("feature_id", "mzmed", "rtmed",
                                "adduct", "ppm_error",
                                "target_formula", "target_name")) |>
    as.data.frame() |>
    unique()
rownames(mtch_res) <- NULL
library(pander)
mtch_res |>
    pandoc.table(style = "rmarkdown", split.table = Inf)
```

- some good matches
- although reference compounds have, for the same feature, the same chemical
  formula, their names as well as their (reported) *exact mass* differs, leading
  to multiple hits per feature.


get run1 data

```{r}
#' Import run1 data
load("data_after_DA.RData")
run1 <- data

col_phenotype <- brewer.pal(8, name = "Dark2")[c(1,2, 5)]
names(col_phenotype) <- c("QC", "CVD",
                          "CTR")
col_sample <- col_phenotype[sampleData(run1)$phenotype]

#import run2 data
load("run2_after_refined.RData")

col_phenotype2 <- brewer.pal(8, name = "Dark2")[c(8, 4, 3)]
names(col_phenotype2) <- c("QC",
                          "CVD",
                          "CTR")
col_sample2 <- col_phenotype2[sampleData(run2)$phenotype]
```

```{r}
# prep inputs - features
query <- featureDefinitions(run1)[, "mzmed", drop = FALSE]
colnames(query) <- "mz"
query$feature_id <- rownames(featureDefinitions(run1))



# prep inputs - database
library(AnnotationHub)
library(CompoundDb)
ah <- AnnotationHub()
query(ah, "MassBank")
mb <- ah[["AH116166"]]

db <- compounds(mb, columns = c("compound_id", "name", "formula", "exactmass"))

# match
param <- Mass2MzParam(adducts = c("[M+H]+", "[M+Na]+", "[M+H-NH3]+"),
                      tolerance = 0.005, ppm = 0)

matched_features <- matchValues(query, db, param)
matched_features #Lot of matches

#Let's check for the differentially abundant features
sign_fts <- c("FT0668", "FT6474", "FT1045", "FT0525", "FT0759")

for(i in sign_fts){
    idc <- which(query$feature_id == i)
    tmp <- matched_features[idc]
    table <- head(as.data.frame(matchedData(tmp, c("target_formula", "target_name",
                                                        "adduct",
                                                        "score", "ppm_error")))
                  , 10)
    table <- table[order(table$score), ]
    pandoc.table(style = "rmarkdown", caption = i, table)
}

# Comment: I will look more into them. But caffeine is still caffeine aha.
# - we can discuss them during our next meeting i'll prep a little background on all of them !
```


# Matching feature from run1 to ms2 spectrum from run2 and annotating

Allows for higher confidence of annotation

```{r eval=FALSE, include=FALSE}
#' Import run2 data
path <- "C:/Users/plouail/OneDrive - Scientific Network South Tyrol/end-to-end_worflow/data/mzML/mzML_LCMSMS/"
filename <- list.files(path = path, pattern = "\\.mzML$")
run2 <- readMsExperiment(paste0(path, filename))

run2 <- filterRt(run2, c(10, 240)) #same filtering as run1

## add quick phenodata
sampleData(run2)$phenotype <- c(rep("CVD", 5), rep("CTR", 5), rep("QC", 5))
sampleData(run2)$frag_method <- c(rep(c("CE20", "CE30", "CE40", "CES", "NA"), 3))

spectra(run2) |>
    msLevel() |>
    split(fromFile(run2)) |>
    lapply(table)
```


```{r prep spectra object}
# ms2 spectra object
low_int <- function(x, ...) {
    x > max(x, na.rm = TRUE) * 0.05
}

run2_spectra <- spectra(run2)|>
    filterMsLevel(2) |>
    filterIntensity(intensity = low_int)

# remove spectra that have one peak only
run2_spectra <- run2_spectra[lengths(run2_spectra) > 1]

#' jo: that's just for me to load the data as a Spectra.
lcmsms_files <- dir("data/mzML_LCMSMS", pattern = "mzML", full.names = TRUE)
run2_spectra <- Spectra(lcmsms_files) |>
    filterMsLevel(2) |>
    filterIntensity(intensity = low_int)
run2_spectra <- run2_spectra[lengths(run2_spectra) > 1]

#' add fragmentation data to spectradata
run2_spectra$frag_method <- regmatches(
    dataOrigin(run2_spectra),
    regexpr("(CE20|CE30|CE40|CES)", dataOrigin(run2_spectra)))
table(run2_spectra$frag_method)

#' database
ref_ms2 <- Spectra(mb)

#' Do same filtering as for our spectra data
ref_ms2 <- filterIntensity(ref_ms2, intensity = low_int)
ref_ms2 <- ref_ms2[lengths(ref_ms2) > 1]
```

## Annotation strategy 1 matchValues

We need to identify the MS2 spectra from *run2* that could represent fragments
of the ions of features from the data in *run1*. First approach: match MS2
spectra from run 2 against features from run 1 based on their precursor m/z and
retention time (that has to be similar (given an acceptable tolerance) than the
feature's *mzmed* and *rtmed*. While being very easy to perform, this approach
does not consider the actual *m/z* and retention time ranges of the features'
chromatographic peaks.

```{r }
#' Only extracting the spectra variables we actually need.
query <- spectraData(
    run2_spectra, columns = c("rtime", "precursorMz", "frag_method"))
#' i have to do that because matchValue does
#' not allow for a Spectra object to be query (I need to look into it)

target <- featureDefinitions(run1)
target$feature_id <- rownames(target)

#' matchvalue + remove the double matches
mtch <- matchValues(query, target, mzColname = c("precursorMz", "mzmed"),
        rtColname = c("rtime", "rtmed"),
        param = MzRtParam(ppm = 10, tolerance = 0, toleranceRt = 2))
#' list the number of features for which we have MS2 spectra
length(unique(mtch$target_feature_id))

#' list the number of MS2 spectra per feature
table(mtch$target_feature_id)

param <- SingleMatchParam(duplicates = "closest", column = "score_rt",
                          decreasing = TRUE)
mtch <- filterMatches(mtch, param)

#' reduce spectra object for which there are matches + get fts ID
res_ms2 <- run2_spectra[queryIndex(mtch)]
res_ms2$feature_id <- rownames(featureDefinitions(run1))[targetIndex(mtch)]

#' match these spectra against massbank. we can do it all in one call
#' note: with tolerance = 0.1 we would get many more matches.
prm <- CompareSpectraParam(ppm = 20, tolerance = 0.0, requirePrecursor = TRUE,
                           THRESHFUN = function(x) which(x >= 0.7))

#' different options below to try to get more db matches.
#' 1) use a different similarity score, e.g. GNPS that should also match
#'   neutral losses
#' 2) use the entropy-based score.
#' 3) remove precursor peak and all peaks with an m/z above that (would more
#'   help to reduce false positives).
#' - relaxing the peak-matching criteria has the biggest influence, i.e.
#'   increasing ppm or even tolerance. We get more matches.
#' - use requirePrecursor = FALSE: get matches for 7 features, but not
#'   necessarily better ones (more false positives).
#' 4) match neutral loss spectra: convert both the query and target spectra to
#'   neutral loss spectra and calculate similarities between them.
#' 5) Use a different database, e.g. GNPS?

## #' 1) GNPS-like matching: not more matches.
## prm <- CompareSpectraParam(FUN = MsCoreUtils::gnps, MAPFUN = joinPeaksGnps,
##                            ppm = 10, requirePrecursor = TRUE,
##                            THRESHFUN = function(x) which(x >= 0.7))

## 2) MS entropy-based matching: not more matches.
## library(msentropy)
## prm <- CompareSpectraParam(FUN = msentropy_similarity, MAPFUN = joinPeaksNone,
##                            requirePrecursor = TRUE, ms2_tolerance_in_ppm = 10,
##                            ms2_toleranec_in_da = -1,
##                            THRESHFUN = function(x) which(x >= 0.7))

## 3) remove peaks >= precursor m/z
## with that we keep caffeine, and in addition a feature at 47 seconds matching
## Aminophylline.
## res_ms2 <- filterPrecursorPeaks(res_ms2, ppm = 50, mz = ">=")
## ref_ms2 <- filterPrecursorPeaks(ref_ms2, ppm = 50, mz = ">=")
## res_ms2 <- res_ms2[lengths(res_ms2) > 1]
## ref_ms2 <- ref_ms2[lengths(ref_ms2) > 1]

## 4) convert all fragment spectra to neutral loss spectra. With that we
## get 3 features Theophyllin (m/z 181.07, RT 33.8), 1,7-Dimethylxanthine
## (m/z 181.07 RT 46) and Caffeine (m/z 195.08 RT 33.5)
## nlp <- PrecursorMzParam(filterPeaks = "abovePrecursor", tolerance = 0.05)
## res_ms2_nl <- neutralLoss(res_ms2, param = nlp)
## length(res_ms2_nl)
## res_ms2_nl <- res_ms2_nl[lengths(res_ms2_nl) > 1]
## length(res_ms2_nl)
## ref_ms2_nl <- neutralLoss(ref_ms2, param = nlp)
## length(ref_ms2_nl)
## ref_ms2_nl <- ref_ms2_nl[lengths(ref_ms2_nl) > 1]
## length(ref_ms2_nl)
## res_ms2_mtch <- matchSpectra(res_ms2_nl, ref_ms2_nl, param = prm)

#' match experimental against reference spectra
register(SerialParam())
res_ms2_mtch <- matchSpectra(res_ms2, ref_ms2, param = prm)
res_ms2_mtch
#' really low percentage of MS2 spectra matched.
length(whichQuery(res_ms2_mtch)) / length(res_ms2_mtch) * 100

#' for how many features do we have MS2 spectra
length(unique(res_ms2_mtch$feature_id))

#' maybe matches are for a particular collision energy?
res_ms2_nomatch <- query(res_ms2_mtch)[-whichQuery(res_ms2_mtch)]
res_ms2_mtch <- res_ms2_mtch[whichQuery(res_ms2_mtch)]

#' for how many features do we have MS2 spectra WITH db matches?
length(unique(res_ms2_mtch$feature_id))

table(res_ms2_nomatch$frag_method)
table(query(res_ms2_mtch)$frag_method)
#' seems like we have mostly hits for CE20 or CES.

#' distribution of score
quantile(res_ms2_mtch$score)
plot(density(res_ms2_mtch$score))

md <- matchedData(res_ms2_mtch, c("rtime", "precursorMz", "feature_id",
                                  "frag_method", "target_inchikey",
                                  "target_name", "score"))
#' we have redundant matches. loop over features and select, for discrete
#' inchikeys, the best matching pair.
md <- split(md, md$feature_id) |>
    lapply(function(x) {
        lapply(split(x, x$target_inchikey), function(z) {
            z[which.max(z$score), ]
        }) |>
            do.call(what = rbind)
    }) |>
    do.call(what = rbind)

md |>
    as.data.frame()

#' scores are high, but only 3 features, two of them match the same compound
#' (Theophylline)

#' jo: original code below
#Annotation
prm <- CompareSpectraParam(ppm = 10, requirePrecursor = TRUE,
                           THRESHFUN = function(x) which(x >= 0.5))
register(SerialParam())

for (i in unique(res_ms2$feature_id)) {
    tmp <- res_ms2[res_ms2$feature_id == i, ]
    mtch <- matchSpectra(tmp, mb, param = prm)
    mtch <- mtch[whichQuery(mtch)]
    if (length(mtch) > 0) {
        tmp <- featureChromatograms(run1, features = i, expandRt= 1)
        plot(tmp, col = col_sample, main = i, lwd = 2)
        abline(v = mtch$rtime)
        grid()
        legend("topright", col = col_phenotype,
               legend = names(col_phenotype), lty = 1, cex = 1)
        table <- head(as.data.frame(spectraData(mtch, c("target_name", "score",
                                                        "rtime",
                                                        "frag_method"))))
        table <- table[order(table$score, decreasing = TRUE), ]
        pandoc.table(style = "rmarkdown", caption = i, table)
    }
}
```

Observations:
- few features are matched to database, and only one that was significant from
  the differential abundance analysis jo: yep, only caffeine matches. the other
  significant features have too low intensities, thus maybe the MS could not
  pick up ions for fragmentation.
- CE20 fragmentation seems to be the one giving all the top results jo: yep,
  maybe, to simplify things, we should restrict to CE20 and drop all other
  files.
- anyway to increase match with database ? jo: it's a bit puzzling
  indeed. Possible reasons/influences: different instruments used (db vs ours):
  m/z values might/can be different if lower precision or mis-calibrated;
  different fragmentation mode; database contains mostly [M+H]+ ion fragments,
  many of our features will be other types of ions -> different precursor m/z
  and fragmentation.


```{r eval=FALSE, include=FALSE}
#' do they map with the feature that were significant ?
annot_fts <- unique(res_ms2$feature_id)
intersect(sign_fts, annot_fts) #one fts has no matches
```


## Annotation strategy 3: Using filterRanges

```{r}
#' here the target will be range of features using featureArea
target <- as.data.frame(featureArea(run1))

#' use this in new filterRanges function (use apply)
test <- apply(target[, c("rtmin", "rtmax", "mzmin", "mzmax")], MARGIN = 1,
              FUN = filterRanges, object = run2_spectra,
              spectraVariables = c("rtime", "precursorMz"))

test1 <- lapply(test, function(x) length(x) > 1)
idc <- which(unlist(test1))
# keep only non null matches
test <- test[idc]

intersect(sign_fts, names(test)) # also missing one signficant

length(annot_fts) # from strategy 1
length(names(test)) #from strategy 2, one less
```

```{r}
# Want to get similar output as before
prm <- CompareSpectraParam(ppm = 10, requirePrecursor = TRUE,
                           THRESHFUN = function(x) which(x >= 0.5))

for (i in names(test)) {
    mtch <- matchSpectra(test[[i]], mb, param = prm)
    mtch <- mtch[whichQuery(mtch)]
    if (length(mtch) > 0) {
        tmp <- featureChromatograms(run1, features = i, expandRt= 1)
        plot(tmp, col = col_sample, main = i, lwd = 2)
        abline(v = mtch$rtime)
        grid()
        legend("topright", col = col_phenotype,
               legend = names(col_phenotype), lty = 1, cex = 1)
        table <- head(as.data.frame(spectraData(mtch, c("target_name",
                                                        "score",
                                                        "rtime",
                                                        "frag_method"))))
        table <- table[order(table$score, decreasing = TRUE), ]
        pandoc.table(style = "rmarkdown", caption = i, table)
    }
}

# Comments: One more annotated peak !
# I could also extend the feature area !!
```


### Alignment: strategy 4, fit loess based on features from run1 and CP from run2 and properly align.
- Using Lama

Let's apply the same preprocessing param as for the run1

```{r eval=FALSE, include=FALSE}
#' chrompeak detect
param <- CentWaveParam(peakwidth = c(1, 8), ppm = 15, integrate = 2)
run2 <- findChromPeaks(run2, param = param, chunkSize = 5, msLevel = 1)

#' refinement
param <- MergeNeighboringPeaksParam(expandRt = 5, expandMz = 0.01, minProp = 0.75)
run2 <- refineChromPeaks(run2, param = param, chunkSize = 5)

save(run2, file = "run2_after_refined.RData")
```
