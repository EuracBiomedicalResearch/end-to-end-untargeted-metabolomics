
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
# Introduction

# Data description

The data represents a subset of samples from a larger experiment and consists of
in total 10 mzML files with 3 samples from individuals with a cardiovascular
disease, 3 samples from healthy donors and 4 QC samples (pool of all samples of
the experiment). The MS data has been restricted to a retention time range from
20 to 230 seconds and an m/z range from 0 to 500. 

NEEEDS UPDATE!


# Data import

The *mzML* files with the raw MS data are located within the *data/mzML* folder
of this repository. [ideally, they should be added and then downloaded from
MassIVE].

```{r}
library(MsExperiment)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(MetaboCoreUtils)

#' read the sample descriptions from an xlsx sheet
pd <- as.data.frame(read_xlsx("data/phenodata.xlsx"))

#' Import the data

#' Massive data bank extraction but for now not. 
MZML_PATH <- "C:/Users/plouail/OneDrive - Scientific Network South Tyrol/end-to-end_worflow/data/mzML"

#' register(MulticoreParam(6)) ask johannes about that
data <- readMsExperiment(paste0(MZML_PATH, "/", pd$mzML_file) ,sampleData = pd)
data

```

- highlights the importance to have a phenodata table 

```{r phenodata, eval=FALSE, echo=TRUE}
#this  thing does not work
pandoc.table(pData(data), style = "rmarkdown",
             caption = "Samples from the data set.")
```

```{r define-colors}
col_phenotype <- brewer.pal(4, "Set1")[c(2, 1, 4)]
names(col_phenotype) <- c("CTR", "CVD", "QC")

col_sample <- col_phenotype[sampleData(data)$group] 
```

## Set up parallel processing 
```{r}
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(2)))
} else {
    register(bpstart(SnowParam(2)))
}
```

The experimental data is now an 'MsExperiment' object
- LC-MS data within that is stored as a spectra object within the MsExperiment object and can be accessed using Spectra() function 
  - Each element in this spectra object is a spectrum - they are organised linearly and are all combined in the same spectra object one after the other (through rt and samples)

- The MsExperiment object manages the linkage between samples and spectra 
  - it's lenght is defined by the number of samples within the object 
  
# First steps with the data 

Let's look through the data 
```{r}
# Access phenotype information 
print("Phenotype info")
sampleData(data)


# Access Spectra Object 
print("spectra info")
spectra(data)

# Check number of samples 
print("number of samples")
length(data)

#' Retention time range for entire dataset 
spectra(data) |>
rtime() |>
range()

#' Retention time range for first sample 
data[1] |> 
spectra() |>
rtime() |>
range()

```
  
We therefore have an dataset of 'r length(spectra(data))' spectra. 
.. put more info if needed

To generate general data overview we can: 
- combine all spectra measured into one single spectrum = Base peak spectrum 
- Aggregate peak intensity for each spectrum (scan) = Base peak chromatogram 
  - orthogonal to the BPS
  
# General quality assessment

## BPC and heatmaps to evaluate LC performance.

```{r bpc}
bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

data <- filterRt(data, c(10, 240))
bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
```
- We first looked through the entire base peak chromatogram and then filtered it with specific retention time 
  - get smaler file size adn easier to read 
```{r not sure what this is}
bpcb <- bin(bpc)
plot(bpcb)

intmat <- do.call(cbind, lapply(bpcb, intensity))
heatmap(intmat)
```

## EIC of internal standards.

We can also look at a single spectrum: 
```{r}
#' Accessing a single spectrum 
exspec <- spectra(data[1])[100]
plotSpectra(exspec)

#' checking its intensity 
intensity(exspec)

#' checking its rtime 
rtime(exspec)

#' Checking its m/z 
mz(exspec)
```

We can therefore assess our dataset by extracting spectrum/region of interest. 
For this we focus on a specific subset of the data were we expect signal for 
compounds that should be present in serum samples. 
- can filter for a specific rtime range and then look at all the spectrum there 

```{r}
#' subsetting for retention time 

exspec <- spectra(data) |> 
  filterRt(c(140,141))
exspec

# subsetting for rtime in our QC samples 

exspecQC <- data[c(1,4, 7,10)] |>
  spectra() |> 
  filterRt(c(140,141))
exspecQC

plotSpectra(exspecQC[1:4])
```

There were 'r length(exspec)' spectra measured in this one second within the entire datase and 'r length(exspecQC)' in our QC samples.

Calculate the mass of a few ion expected to be seen in the dataset - maybe that you saw just before
- then calculate the ion mass for these - create a variable in which you put it
- use this variable to subset MS data for all ion with this mass - check the chromatogram for this range ( take in note the rtime range)

Next need to generate extracted ion chromatogram (XIC) for all these "test ions" 
```{r}
#'Calculating ion mass for Serine

mass_serine <- calculateMass("C3H7NO3")
serine_mz <- mass2mz(mass_serine, "[M+H]+")
serine_mz <- serine_mz[1, 1]

#' More refined XIC from QC samples 
chr_serine <- (chromatogram(data[c(1,4,7,10)], rt = c(164, 200),
                           mz = serine_mz + c(-0.05, 0.05),
                           aggregationFun = "max"))
plot(chr_serine)

#' under here is test  to analyse multiple ions at the same time, however i am struggling a bit with the fact that they have a wide range of rtime and therefore make downstream analysis less clear for people. 
#either need to be improve, change ions of interest or just do one ion by one. the code works though 

#' first create a data.frame that will store the compound of interest and their calculated ion mass
well_known <- data.frame(row.names = c("serine", "glycine", "creatine", "glucose"))
well_known$Formula <- c("C3H7NO3", "C2H5NO2", "C4H9N3O2", "C6H12O6")

well_known$Mass <- calculateMass(well_known$Formula)
well_known$mz <- mass2mz(well_known$Mass, "[M+H]+")

#create a list of chromatogram in the QC samples for all the compound 
list_names <- row.names(well_known)
chr_list <- list()
for (i in 1:length(well_known$mz)) {
  print(i)
  chr_name <- paste0("chr_" , list_names[i])
  chr <- chromatogram(data[c(1,4,7,10)], rt=c(25, 185), mz = well_known[i,3] + c(-0.05, 0.05)) #
  chr_list[[chr_name]] <-  chr
  plot(chr_list[[chr_name]], main = chr_name)
}

```

These well-known ions can be used later for pre-processing

# Data pre-processing

## Chromatographic peak detection

- run with the default settings, evaluate signal for e.g. serine.

use the findChromPeaks function within xcms
- the preferred algorithm is the CentwaveParam - better for non-Gaussian shape which is what we usually get with HILIC separation (other algorithm also exist)
```{r}

#' Use default Centwave parameter, and evaluate for serine. 
cwp <- CentWaveParam()
default <- findChromPeaks(chr_serine, param= cwp)
chromPeaks(default)


#' With more accurate parameters 
cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 40, integrate = 2)
chr_serine_test <- findChromPeaks(chr_serine, param= cwp)
chromPeaks(chr_serine_test)
plot(chr_serine_test)


##' Here again test for multiple ions at once, works but again bc rtime is so different, cannot see super clearly
#' Evaluate signal for common ions
#' use the previously build list of XIC for common ions 
cwp <- CentWaveParam()
defaultrun <- findChromPeaks(chr_list[[1]], param = cwp )
chromPeaks(defaultrun)

cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 40, integrate = 2)
list_names <- row.names(well_known)
for (i in 1:length(chr_list)) { 
  print(i)
  chr_names <- paste0("chr_" , list_names[i])
  batch_chr  <- findChromPeaks(chr_list[[i]], param = cwp )
  print(chr_names)
  print(chromPeaks(batch_chr))
  plot(batch_chr, main = chr_name)
}

```

- re-run with adapted settings.
```{r run find chrompeak on entire dataset}

data <- findChromPeaks(data, param = cwp, chunkSize = 5)
data

#' Test if we find serine again 

xic_serine <- chromatogram(data, mz = c(106.04, 106.06),
                           rt = c(170, 186))
chromPeaks(xic_serine) 
plot(xic_serine)
```

- merge chromatographic peaks 

```{r merging }
mpp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                  minProp = 3/4) 
data_pp <- refineChromPeaks(data_pp, param = mpp, chunkSize = 5)

#' check how it went 
#' if all good replace data by the merged data 
#' 
```

## Retention time alignment

- use initial correspondence.
- use subset alignment.

## Correspondence

- use *bad* settings (check maybe xcmsTutorials for examples)

## Gap filling

- compare signal for filled-in and detected signal for QC samples. is it
  correlated?
  

# Data normalization

- between sample normalization
- maybe skip signal drift normalization
- Evaluation on IS.

# Identification of interesting features

- Pre-filtering.
- Differential abundance.

Task: sensitivity analysis: with/without normalization. with/without
pre-filtering.


# Annotation

- Different levels of annotation.
- Just m/z (mass).
- m/z and retention time.
- MS/MS spectra + public repository.
- MS/MS spectra + retention time.

# Summary

# Session information

# References

