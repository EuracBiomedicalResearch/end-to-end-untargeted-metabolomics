
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
# Introduction

# Data description

The data represents a subset of samples from a larger experiment and consists of
in total 10 mzML files with 3 samples from individuals with a cardiovascular
disease (), 3 samples from healthy donors and 4 QC samples (pool of all samples of
the experiment). The MS data has been restricted to a retention time range from
20 to 230 seconds and an m/z range from 0 to 500. 

NEEEDS UPDATE!


# Data import

The *mzML* files with the raw MS data are located within the *data/mzML* folder
of this repository. [ideally, they should be added and then downloaded from
MassIVE].

```{r}
library(MsExperiment)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(MetaboCoreUtils)
library(pheatmap)

#' read the sample descriptions from an xlsx sheet
pd <- as.data.frame(read_xlsx("data/phenodata.xlsx"))

#' Import the data

#' Massive data bank extraction but for now not. 
MZML_PATH <- "C:/Users/plouail/OneDrive - Scientific Network South Tyrol/end-to-end_worflow/data/mzML"

#' register(MulticoreParam(6)) ask johannes about that
data <- readMsExperiment(paste0(MZML_PATH, "/", pd$mzML_file) ,sampleData = pd)
data



```

- highlights the importance to have a phenodata table 

There is 'r length(sampleData(data))' samples in this dataset.Here are some 
abbreviation necessary to properly read the phenodata table.
- Injection Index:
- QC: Quality control sample 
- CVD: 
- CTR: 

```{r phenodata, echo=FALSE}
data |>
  sampleData() |> 
  as.data.frame() |>
  pandoc.table(style = "rmarkdown", caption = "Samples from the data set.")
```

```{r define-colors}
#' Define colors for the groups.
col_phenotype <- brewer.pal(4, "Set1")[c(2, 1, 4)]
names(col_phenotype) <- c("CTR", "CVD", "QC")

col_sample <- col_phenotype[sampleData(data)$phenotype] 
```

## Set up parallel processing 
```{r}
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(2)))
} else {
    register(bpstart(SnowParam(2)))
}
```

The experimental data is now an 'MsExperiment' object
- LC-MS data within that is stored as a spectra object within the MsExperiment object and can be accessed using Spectra() function 
  - Each element in this spectra object is a spectrum - they are organised linearly and are all combined in the same spectra object one after the other (through rt and samples)

- The MsExperiment object manages the linkage between samples and spectra 
  - it's lenght is defined by the number of samples within the object 
  
# First steps with the data 

Let's look through the data 
```{r}
# Access phenotype information 
print("Phenotype info")
sampleData(data)


# Access Spectra Object 
print("spectra info")
spectra(data)

# Check number of samples 
print("number of samples")
length(data)

#' Retention time range for entire dataset 
spectra(data) |>
rtime() |>
range()

#' Retention time range for first sample 
data[1] |> 
spectra() |>
rtime() |>
range()

```
  
We therefore have an dataset of 'r length(spectra(data))' spectra. 
.. put more info if needed

To generate general data overview we can: 
- combine all spectra measured into one single spectrum = Base peak spectrum 
- Aggregate peak intensity for each spectrum (scan) = Base peak chromatogram 
  - orthogonal to the BPS
  
# General quality assessment

## BPC and heatmaps to evaluate LC performance.

Data coming from LC-MS experiments are usually analyzed along the retention time axis. MS data is organized by spectrum and hence orthogonally to the retention time axis.
```{r bpc}

bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

#' Filter the data based on retention time, allows to get smaller file size
data <- filterRt(data, c(10, 240))
bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
```
- We first looked through the entire base peak chromatogram and then filtered it with specific retention time 
  - get smaller file size and easier to read 
  
  
  
```{r heatmap}
bpcb <- bin(bpc)
intmat <- do.call(cbind, lapply(bpcb, intensity))
simmat <- cor(intmat)
pheatmap(simmat)
#' improve this labelling
#' 
#' Total ion chromatogram - and heatmap 
tic <- chromatogram(data, aggregationFun = "sum")
plot(tic,col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
btic <- bin(tic)
ticmap <- do.call(cbind, lapply(btic, intensity))
sticmap <- cor(ticmap)
pheatmap(sticmap)
```

## XIC of internal standards.

We can also look at a single spectrum: 
```{r}
#' Accessing a single spectrum 
exspec <- spectra(data[1])[100]
plotSpectra(exspec)

#' checking its intensity 
intensity(exspec)

#' checking its rtime 
rtime(exspec)

#' Checking its m/z 
mz(exspec)
```

We can therefore assess our dataset by extracting spectrum/region of interest. 
For this we focus on a specific subset of the data were we expect signal for 
compounds that should be present in serum samples. 
- can filter for a specific rtime range and then look at all the spectrum there 

```{r}
#' subsetting for retention time 

exspec <- spectra(data) |> 
  filterRt(c(140,141))
exspec

# subsetting for rtime in our QC samples 

exspecQC <- data[c(1,4, 7,10)] |>
  spectra() |> 
  filterRt(c(140,141))
exspecQC

plotSpectra(exspecQC[1:4]) # here too many to show all, maybe talk what we want to show specifically 
```

There were 'r length(exspec)' spectra measured in this one second within the entire datase and 'r length(exspecQC)' in our QC samples.

Calculate the mass of a few ion expected to be seen in the dataset - maybe that you saw just before
- then calculate the ion mass for these - create a variable in which you put it
- use this variable to subset MS data for all ion with this mass - check the chromatogram for this range ( take in note the rtime range)

Next need to generate extracted ion chromatogram (XIC) for all these "test ions" 
```{r}
#'Calculating ion mass for Serine

mass_serine <- calculateMass("C3H7NO3")
serine_mz <- mass2mz(mass_serine, "[M+H]+")
serine_mz <- serine_mz[1, 1]

#' More refined XIC from QC samples 
chr_serine <- (chromatogram(data[c(1,4,7,10)], rt = c(164, 200),
                           mz = serine_mz + c(-0.05, 0.05),
                           aggregationFun = "max"))
plot(chr_serine)

#' Also show another XIC that is less obvious (glycine or something else that has 2 distinct peak)

#mass_ <- calculateMass("C3H7NO3")
#_mz <- mass2mz(mass_, "[M+H]+")
#_mz <- _mz[1, 1]

#' More refined XIC from QC samples 
#chr_ <- (chromatogram(data[c(1,4,7,10)], rt = c(164, 200),
                          # mz = _mz + c(-0.05, 0.05),
                           #aggregationFun = "max"))
#plot(chr_)

# put all samples, but keep the colours


#' under here is test  to analyse multiple ions at the same time, however i am 
#' struggling a bit with the fact that they have a wide range of rtime and 
#' therefore make downstream analysis less clear for people. 
#' either need to be improve, change ions of interest or just do one ion by one. 
#' the code works though 

#' first create a data.frame that will store the compound of interest and their
#'  calculated ion mass
well_known <- data.frame(
  row.names = c("serine", "glycine", "creatine", "glucose"))

well_known$Formula <- c("C3H7NO3", "C2H5NO2", "C4H9N3O2", "C6H12O6")

well_known$Mass <- calculateMass(well_known$Formula)
well_known$mz <- mass2mz(well_known$Mass, "[M+H]+")

#create a list of chromatogram in the QC samples for all the compound 
list_names <- row.names(well_known)
chr_list <- list()
for (i in 1:length(well_known$mz)) {
  print(i)
  chr_names <- paste0("chr_" , list_names[i])
  chr <- chromatogram(data[c(1,4,7,10)], rt=c(25, 185), 
                      mz = well_known[i,3] + c(-0.05, 0.05)) 
  chr_list[[chr_names]] <-  chr
  plot(chr_list[[chr_names]], main = chr_names)
}
# sodium 

```

These well-known ions can be used later for pre-processing

# Data pre-processing

## Chromatographic peak detection

- run with the default settings, evaluate signal for e.g. serine.

use the findChromPeaks function within xcms
- the preferred algorithm is the CentwaveParam - better for non-Gaussian shape which is what we usually get with HILIC separation (other algorithm also exist)
```{r}

#' Use default Centwave parameter, and evaluate for serine. 
cwp <- CentWaveParam()
default <- findChromPeaks(chr_serine, param= cwp)
chromPeaks(default)

#' do same with second chosen ion

#' With more accurate parameters 
cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 40, integrate = 2)
chr_serine_test <- findChromPeaks(chr_serine, param= cwp)
chromPeaks(chr_serine_test)
plot(chr_serine_test)

#' do same with second chosen ion
#' 


##' Here again test for multiple ions at once, works but again bc rtime is so different, cannot see super clearly
#' Evaluate signal for common ions
#' use the previously build list of XIC for common ions 
cwp <- CentWaveParam()
defaultrun <- findChromPeaks(chr_list[[1]], param = cwp )
chromPeaks(defaultrun)

cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 40, integrate = 2)
list_names <- row.names(well_known)
for (i in 1:length(chr_list)) { 
  print(i)
  chr_names <- paste0("chr_" , list_names[i])
  batch_chr  <- findChromPeaks(chr_list[[i]], param = cwp )
  print(chr_names)
  print(chromPeaks(batch_chr))
  plot(batch_chr, main = chr_names)
}


```

- re-run with adapted settings.

```{r run find chrompeak on entire dataset}

data <- findChromPeaks(data, param = cwp, chunkSize = 5)
data

#' Test if we find serine again 
xic_serine <- chromatogram(data, mz = c(106.04, 106.06),
                           rt = c(170, 186))
chromPeaks(xic_serine) 
plot(xic_serine, main = "XIC serine with identified chromatographic peaks")

#' same wiht second chosen ion 

```
These chrompeask can also be seen in generic plots such as below: 
```{r}
srn <- data |>
filterRt(rt = c(175, 188)) |>
filterMz(mz = c(106.04, 106.06))

plot(srn[1])
```

### Refine chromatographic peaks 

The identification of chromatographic peaks can sometimes lead to peak detection 
artifacts, either overlapping or splits. The function 'refineChromPeaks' is used
in this case in combination with the 'MergeNeighboringPeaksParam'. 
This function will results in either removing of peaks that do not meet the 
condition stated in the parameter or merge peaks that were artificially split 
in the previous step. 

```{r merging }

#' set up the parameter 
mnpp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                   minProp = 3/4) 

#' Apply on whole dataset
data_pp <- refineChromPeaks(data, param = mnpp, chunkSize = 5)
chromPeakData(data_pp)

#' check how it went
#' struggling to find an area to check here # backtrack using the chrompeaksdata 

par(mfrow = c(1, 2))
plotChromPeaks(data, 1)
plotChromPeaks(data_pp, 1)


#' if all good replace data by the merged data 
data <- data_pp



```

## Retention time alignment

- use initial correspondence.

Let's buildlook at the bpc again: 
```{r}
bpc_raw <- data |>
  chromatogram(aggregationFun = "max")

plot(bpc_raw, peakType = "none", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

#change color of non QC so they are less visible 
```

Here we can see that the QC samples that were measured with the same setup on 
the same day show a slight drifts of the signal are visible.

```{r}

# Grouping the peaks according to 
pdp <- PeakDensityParam(sampleGroups = sampleData(data)$phenotype,
                        minFraction = 0.75,
                        binSize = 0.01,
                        bw = 2)
data <- groupChromPeaks(data, param = pdp)



#' Define parameters of choice
pgp <- PeakGroupsParam(minFraction = 0.9, extraPeaks = 50, span = 0.3,
                       subsetAdjust = "average",
                       subset = which(sampleData(data)$phenotype == "QC"))

#' Input in the function
data <- adjustRtime(data, param = pgp)

#' See result
plotAdjustedRtime(data, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)


```

```{r bpc before and after}
par(mfrow = c(2, 1))
#' Plot the raw base peak chromatogram
data_raw <- dropAdjustedRtime(data)
plot(bpc_raw, peakType = "none")
#' Plot the BPC after alignment
plot(chromatogram(data, aggregationFun = "max", chromPeaks = "none"))
```


- use subset alignment.

```{r specific ion before and after}
#' Similar comparison but this time filtering to see specific ion
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
chromatogram(data_raw, mz = c(106.04, 106.06), rt = c(170, 186)) |>
plot()

#' Extract the bpc for serine after the adjusted time 
bpc_serine <- chromatogram(data,  mz = c(106.04, 106.06), rt = c(170, 186))
plot(bpc_serine)


#add the second ion 
```

## Correspondence

- use *bad* settings (check maybe xcmsTutorials for examples)

```{r}
#' Use creatine here as a bad example ? 
#' Default parameter for the grouping 
#' Apply them to the serien BPC 
#' 
#'Now apply them to creatine / or another ions that shows it
#'
#'Updating parameters
pdp <- PeakDensityParam(sampleGroups = sampleData(data)$phenotype,
                        minFraction = 1/3, binSize = 0.015, bw = 2.3)

#' Apply to creatine 

```

- Good settings 

```{r}
#' Now apply to whole data
data <- groupChromPeaks(data, param = pdp)

data <- fillChromPeaks(data, param = ChromPeakAreaParam(), chunkSize = 5)

```

## Gap filling

- compare signal for filled-in and detected signal for QC samples. is it
  correlated?
  

# Data normalization

- between sample normalization
- maybe skip signal drift normalization
- Evaluation on IS.

# Identification of interesting features

- Pre-filtering.
- Differential abundance.

Task: sensitivity analysis: with/without normalization. with/without
pre-filtering.


# Annotation

- Different levels of annotation.
- Just m/z (mass).
- m/z and retention time.
- MS/MS spectra + public repository.
- MS/MS spectra + retention time.

# Summary

# Session information

# References

