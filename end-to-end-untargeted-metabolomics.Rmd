---
title: "End-to-end workflow for LC-MS/MS analysis using *MsExperiment* and *Spectra*"
author:
  - name: "Philippine Louail"
affiliation: "Eurac Research, Bolzano, Italy"
output: rmdformats::html_clean   
date: "2023-09-07"
---

```{r style, message = FALSE, echo = FALSE, warning = FALSE, results = "asis"}
library("BiocStyle")
library("knitr")
library("rmarkdown")
opts_chunk$set(message = FALSE, error = FALSE, warning = FALSE,
               cache = FALSE, fig.width = 7, fig.height = 7)
```

# Abstract 

Untargeted Ms/MS analysis has... (one sentence intro on the technic). 
Currently, numerous specialized packages cater to specific analysis steps but 
often lack flawless integration. Here, we introduce an R pipeline leveraging 
*Spectra* and *MsExperiment* to encompass all pre-processing and downstream 
analyses of LC-MS/MS datasets in a reproducible manner. Our pipeline seamlessly
integrates Bioconductor packages, offering adaptability to diverse study designs
and analysis requirements.

# Keyword
LC-MS/MS, pre-processing, normalization, feature identification... 

# Introduction

- Relevancy of the technic
- Challenges (explaining the need for seamless integragration and overall pipeline)
- Thus we propose a highly-detailed and adaptable pipeline for LC-MS/MS data analysis. 
Comprised of pre-processing steps based on the *xcms* package, which is highly 
adaptable to dataset-specific requirement... 

# Data description

The data represents a subset of samples from a larger experiment and consists of
in total 10 mzML files with 3 samples from individuals with 
arrhymogenic cardiomyopathie (AOC) a cardiovascular disease, 3 samples from 
healthy donors and 4 QC samples (pool of all samples of the experiment). 
The MS data has been restricted to a retention time range from
20 to 230 seconds and an m/z range from 0 to 500 (it has not but should i ?. 

NEEEDS UPDATE!

The data and metadata used in this workflow can be found on the masssive database under the ID: 


# Workflow description 

This pipleine here describes all steps required to preprocess and assign 
features identity to LC-MS/MS data. It is performed thanks to the *MsExperiment*
and *PSpectra* packages that integrate multiple Bioconductor packages for 
LC-MS/MS analysis. The pre-processing steps are performed using the *xcms* 
packages and consist of Chromatogrphic peak detection, retention time alignment 
and Correspondence.  The pre-processing of the data is then followed by 
normalization, identification of features and lastly annotation of these 
features. Laslty, *RColorBrewer*, *pander*, and *pheatmap* were used for data 
visualization.

Our workflow is therefore based on the following dependencies: 

```{r packages used}
library(MsExperiment)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(MetaboCoreUtils)
library(pheatmap)
```

# Data import

The *mzML* files with the raw MS data are located within the *data/mzML* folder
of this repository. [ideally, they should be added and then downloaded from
MassIVE].

```{r}
#' read the sample descriptions from an xlsx sheet
pd <- as.data.frame(read_xlsx("data/phenodata.xlsx"))

#' Import the data
#' Massive data bank extraction but for now not. 
MZML_PATH <- "C:/Users/plouail/OneDrive - Scientific Network South Tyrol/end-to-end_worflow/data/mzML"

#' register(MulticoreParam(6)) ask johannes about that
data <- readMsExperiment(paste0(MZML_PATH, "/", pd$mzML_file) ,sampleData = pd)
```

... just a tiny text with default everything is parallelized


```{r}
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(2)))
} else {
    register(bpstart(SnowParam(2)))
}
```

# Data organisation


The experimental data is now a `MsExperiment` object:
```{r}
data
```

This `MsExperiment` object manages the linkage between samples and spectra. 
Its length is defined by the number of samples within the object. The phenodata 
is a crucial aspect of LC-MS/MS analysis. It can be accessed using 
`sampleData()`. The Table 1 below shows us more details about our dataset's 
samples.

There is `r length(sampleData(data))` samples in this dataset. Here are some 
abbreviation necessary to properly read the phenodata table:

- Injection Index:..
- QC: Quality control sample 
- CVD: Cardiovascular disease
- CTR: Control

Metadata in our `MsExperiment` object is accessed using the `sampleData()` 
function. we used this and the *pander* package to build this table representing
the metadata of our study (table 1)

```{r phenodata, echo=FALSE}
print("Table 1.Samples from the data set.")
as.data.frame(sampleData(data)[,-5]) |>
pandoc.table(style = "rmarkdown", caption = "Samples from the data set.", )
```

```{r define-colors, include=FALSE}
#' Define colors for the groups.
col_phenotype <- brewer.pal(4, "Set1")[c(2, 1, 4)]
names(col_phenotype) <- c("CTR", "CVD", "QC")

col_sample <- col_phenotype[sampleData(data)$phenotype] 
```


The MS data of this experiment is stored as a `Spectra` object within the 
`MsExperiment` object and can be accessed using `Spectra()` function. 
Each element in this object is a spectrum - they are organised linearly and are 
all combined in the same `spectra` object one after the other (through retention
time and samples).

```{r}
# Access Spectra Object 
spectra(data)
```
  
```{r}
# Check number of samples 
length(data)
```

We therefore have an data set of `r length(data)` samples for a total of `r length(spectra(data))` spectra. 
Below we also determine the retention time range for the entire data set.
```{r}
#' Retention time range for entire dataset 
spectra(data) |>
rtime() |>
range()
```


Data coming from LC-MS experiments are usually analyzed along the retention time
axis. MS data is organized by spectrum and hence orthogonal to the retention 
time axis. The `chromatogram()` function therefore allows to extract intensities
along retention time. The access to chromatographic information is not as 
efficient and seamless as for spectra information but development of a 
`chromatogram` object as thorough and easy of use as the `Spectra` object is 
underway. 

# Data visualization and general quality assessment

Visualization is crucial for inspection and quality assessment of MS data. 
To generate general overview of our LC-MS/MS we can: 

- Combine all spectra measured into a single spectrum = Base peak spectrum (BPS)
- Aggregate peak intensity for each spectrum = Base peak chromatogram (BPC), 
which is orthogonal to the BPS
  
## Visualisation of spectra data 

BPS collapses data in the retention time dimension. such visualization provides 
information on the most abundant mass-to-charge values (m/z) ub the data set 
regardless of the rtime in which they were measured. Compared to the BPC, BPS 
visualization is not as straightforward. Indeed, mass peaks, even if 
representing signal from the same ion, will never be identical between 
consecutive spectra, but will slightly differ based on the measurement 
error/resolution of the instrument. 

```{r bps }
bps <- combineSpectra(spectra(data), f = fromFile(data),
                      intensityFun = max, ppm = 5)  

par(mfrow = c(2,1), mar =c(2,1,1,1))
plotSpectra(bps[1], main = "BPS sample 1")
plotSpectra(bps[6], main = "BPS sample 6")
```

These BPS thus show the most common ions present in each of the samples. There 
seem to be some overlap in ion content between the files (around 300 m/z and 
700 m/z), but also some quite distinct signals.

It is also highly suggested to explore the data in more details. This can easily be done by assessing our data extracting spectrum/region of interest.

```{r }
#' Accessing a single spectrum 
exspec <- spectra(data[1])[100]
plotSpectra(exspec)
```

- Describe the spectrum and the mains peaks 

We can then explore details about this specific spectrum by using a wide range 
of functions:
```{r}
#' checking its intensity 
intensity(exspec)

#' checking its rtime 
rtime(exspec)

#' Checking its m/z 
mz(exspec)
```

We can focus on a specific subset of the data at a specific rtime range and then
look at all the spectrum there 

```{r example accessing all spectrum at specific seconde}
exspec <- data |>
  filterMz(c(230,250)) |> 
  spectra() |> 
  filterRt(c(209,210))
plotSpectra(exspec[1:4]) 
```


There were `r length(exspec)` spectra measured in this one second within the 
entire dataset (we only show 4 here) . After plotting them, we can spot several 
mass peaks, a common peak can be seen at 241 m/z which could represent the ion 
of Cystine We can look into this a bit later.


## Chromatogram data and heatmaps to evaluate LC performance.

For LC-MS data visualizing, a base peak chromatogram (BPC) or total ion 
chromatogram (TIC) would for example allow to evaluate the performance of the 
liquid chromatography of the various samples in an experiment. To create such a 
plot we below extract the BPC from our data. The BPC extracts the maximum peak 
signal from each spectrum in a data file and plots this information 
(on the y-axis) against the retention time for that spectrum. The BPC can be 
extracted using the `chromatogram` function. 
With parameter `aggregationFun = "max"` we define to report the maximum signal 
per spectrum. On the other hand setting `aggregationFun = "sum"` sum up all 
intensities of a spectrum and hence create a TIC.

```{r bpc}
#' First extract and plot bpc for full data
bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80), main = "BPC")
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

#' Filter the data based on retention time
data <- filterRt(data, c(10, 240))
bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80), main = "BPC after filtering")
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
```

We first looked through the entire base peak chromatogram and then filtered it 
with specific retention time this allows to get smaller file size and an easier
to read BPC. 

This last plot hence shows th BPC for each samples and give us information on 
the retention time captured during our experiment, therefore at what retention 
time compounds eluted from the LC column. Essentially, a BPC collapses the 
3-dimensional LC-MS data (m/z by retention time by intensity) into 2 dimensions 
(retention time by intensity)
  
```{r heatmap}
#' Heatmap from total ion chromatogram 
tic <- chromatogram(data, aggregationFun = "sum")
tic <- bin(tic)
ticmap <- do.call(cbind, lapply(tic, intensity))
ticmap <- cor(ticmap)
pheatmap(ticmap)
```


## XIC of internal standards.

Trhoughout the entire rpocess it is important to be able to refer to know part 
of the datatset, such as well known ions. In this workflow we selected ions that 
are commonly present in human blood serum.
Below,we generate extracted ion chromatogram (EIC) for these "test ions" 

```{r EIC}
#'Calculating ion mass for:
#' Cystine  
mass_cystine <- calculateMass("C6H12N2O4S2")
cystine_mz <- mass2mz(mass_cystine, "[M+H]+")
cystine_mz <- cystine_mz[1, 1]

chr_cystine <- (chromatogram(data, rt = c(195, 218),
                           mz = cystine_mz + c(-0.05, 0.05),
                           aggregationFun = "max"))

#' 1- Methylhistidine
mass_1Met <- calculateMass("C7H11N3O2")
Met_mz <- mass2mz(mass_1Met, "[M+H]+")
Met_mz <- Met_mz[1, 1]

chr_Met <- (chromatogram(data, rt = c(170, 200),
                           mz = Met_mz + c(-0.05, 0.05),
                           aggregationFun = "max"))
#' plot EIC
par(mfrow = c(1, 2))
plot(chr_cystine, main = "Cystine", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
plot(chr_Met, main = "1- Methylhistidine", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

```

... describe EICs


# Data pre-processing

Pre-processing is the first step in the analysis of untargeted LC-MS or gas 
chromatography (GC)-MS data. The aim of the pre-processing is the quantification
of signals from ions measured in a sample, adjusting for any potential retention
time drifts between samples and the matching of the quantified signal across 
samples within an experiment. ..

## Chromatographic peak detection

The first pre-processecing step is to detect the presence of peaks along 
retention time. For this purpose we use the findChromPeaks function within xcms,
the preferred algorithm is the CentwaveParam - better for non-Gaussian shape 
which is what we usually get with HILIC separation (other algorithm also exist)

```{r Default centaweve param test}
##' Use default Centwave parameter
#' Evaluate for Cystine 
cwp <- CentWaveParam()
default <- findChromPeaks(chr_cystine, param= cwp)
chromPeaks(default)

#' Evaluate for 1- Methylhistidine
default <- findChromPeaks(chr_Met, param= cwp)
chromPeaks(default)

```

describe why no peaks and the different parameters that can be changed  

refer to previous figures to determine peakwidth


the other parameter we need to look at is the `ppm =`. For this we will.. 

```{r ppm parameter }

#' Restrict the data to signal from Cystine
cst <- data |>
filterRt(rt = c(195, 218)) |>
filterMz(mz = cystine_mz + c(-0.05, 0.05))

#' Reduce the data set to signal of the [M+H]+ ion of cystine
cst_1 <- cst[1] |>
    filterMzRange(cystine_mz + c(-0.01, 0.01)) |>
    spectra() 

lengths(cst_1) #how to get better numbers ?

#' Calculate the difference in m/z values between scans
mz_diff <- cst_1 |>
    mz() |>
    unlist() |>
    diff() |>
    abs()

#' Express it in ppm
range(mz_diff * 1e6 / mean(unlist(mz(cst_1))))
```

.. we take a ppm value close to the maximum of this range.


Now re-run with adapted settings.

```{r}
#' With more accurate parameters 
cwp <- CentWaveParam(peakwidth = c(1, 8), ppm = 50, integrate = 2)

chr_cystine_test <- findChromPeaks(chr_cystine, param= cwp)
head(chromPeaks(chr_cystine_test))

chr_Met_test <- findChromPeaks(chr_Met, param= cwp)
head(chromPeaks(chr_Met_test))

#' Plot test chromatogram
par(mfrow = c(1, 2))
plot(chr_cystine_test, main = "Cystine", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
plot(chr_Met_test, main = "1- Methylhistidine", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

```


Now... 

So we can go on to apply this algorithm to the entire data set we then extract 
the EIC for our two ions test. 


```{r run find chrompeak on entire dataset}
data <- findChromPeaks(data, param = cwp, chunkSize = 5)

#' Test if we find cystine and 1- Methylhistidine again 
eic_cystine <- chromatogram(data, mz = cystine_mz + c(-0.05, 0.05),
                           rt = c(205, 215))
eic_Met <- chromatogram(data, mz = Met_mz + c(-0.05, 0.05),
                           rt = c(180, 195))

#' Plot 
par(mfrow = c(1, 2))
plot(eic_cystine, main = "EIC Cystine", 
     col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
plot(eic_Met, main = "EIC 1- Methylhistidine", 
     col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

```

The EIC confirm the Chromatographic peak detection was suscessful. 
These chrompeaks can also be seen in generic plots such as below: 


```{r}
cst <- data |>
filterRt(rt = c(195, 218)) |>
filterMz(mz = cystine_mz + c(-0.05, 0.05))

plot(cst[1]) # discuss this, because ugly small peak
```



### Refine chromatographic peaks 

The identification of chromatographic peaks can sometimes lead to peak detection 
artifacts, either overlapping or splits. The function `refineChromPeaks` is used
in this case in combination with the `MergeNeighboringPeaksParam`. 
This function will merge peaks that were artificially split in the previous step. 


A few examples of peak detection artifacts: 
```{r echo=FALSE}

#' Extract m/z-rt regions for selected peaks
mz_rt <- data.frame(row.names=c("CP114011", "CP113979", "CP114968"), 
                    rtmin = c(165.2120, 191.71800,  22.9190),
                    rtmax = c(191.0710, 218.13500,  46.5460), 
                    mzmin = c(191.0338,  53.51464, 462.1994),
                    mzmax = c(191.0477, 53.52683, 462.3044))

mz_rt <- as.matrix(mz_rt)

#' Expand the rt range by 10 seconds on both sides
mz_rt[, "rtmin"] <- mz_rt[, "rtmin"] - 10
mz_rt[, "rtmax"] <- mz_rt[, "rtmax"] + 10
#' Expand the m/z range by 0.005 on both sides
mz_rt[, "mzmin"] <- mz_rt[, "mzmin"] - 0.005
mz_rt[, "mzmax"] <- mz_rt[, "mzmax"] + 0.005

#' Extract the EICs
eics <- chromatogram(data[3], rt = mz_rt[, c("rtmin", "rtmax")],
                     mz = mz_rt[, c("mzmin", "mzmax")])
#' Plot the EICs
plot(eics)

```


```{r merging }
#' set up the parameter 
mnpp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                   minProp = 3/4) 

#' Perform the peak refinement on the EICs
eics <- refineChromPeaks(eics, param = mnpp)
plot(eics)
```

... Describe:

- the parameters chosen 
- the changes. 


```{r}
#' Apply on whole dataset
data <- refineChromPeaks(data, param = mnpp, chunkSize = 5)
chromPeakData(data)
```



## Retention time alignment

- use initial correspondence.

Let's build and look at the bpc again: 
```{r}
bpc_raw <- data |>
  chromatogram(aggregationFun = "max")
plot(bpc_raw, peakType = "none", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

#change color of non QC so they are less visible, or just leave QC I think it would be fore readable 
```

Here we can see that the QC samples that were measured with the same setup on 
the same day show a slight drifts of the signal are visible.

- Discuss protocol, find main peaks to base the lignment to,...

```{r}

# Grouping the peaks according to 
pdp <- PeakDensityParam(sampleGroups = sampleData(data)$phenotype,
                        minFraction = 0.75,
                        binSize = 0.01,
                        bw = 2)
data <- groupChromPeaks(data, param = pdp)

#' Define parameters of choice
pgp <- PeakGroupsParam(minFraction = 0.9, extraPeaks = 50, span = 0.3,
                       subsetAdjust = "average",
                       subset = which(sampleData(data)$phenotype == "QC"))

#' Input in the function
data <- adjustRtime(data, param = pgp)

#' See result
plotAdjustedRtime(data, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)


```


We can also compare before and after alignment, to access data before the 
process, the function `dropAdjustedRtime()` can be used:
```{r}
#' get  data before alignment
data_raw <- dropAdjustedRtime(data)
```

We can use this to compare the BPC before and after alignment

```{r bpc before and after, echo=FALSE}

#' Plot the BPC before and after alignment
par(mfrow = c(2,1), mar = c(2, 1, 1, 0.5))
plot(bpc_raw, peakType = "none", main = "BPC before alignment", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
plot(chromatogram(data, aggregationFun = "max", chromPeaks = "none"), main = "BPC after alignment", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
```


- use subset alignment.

Can also observe it in our ions of interest:

```{r specific ion before and after, echo=FALSE}
#' Similar comparison but this time filtering to see cystine
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
old_eic_cystine <- chromatogram(data_raw, mz = cystine_mz + c(-0.05, 0.05), rt = c(205, 214))
plot(old_eic_cystine)
eic_cystine <- chromatogram(data,  mz = cystine_mz + c(-0.05, 0.05), rt = c(205, 214)) 
plot(eic_cystine)
```

Little difference

```{r echo=FALSE}
#' Same for Met
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
old_eic_Met <- chromatogram(data_raw, mz = Met_mz + c(-0.05, 0.05), 
                            rt = c(175, 195)) 
plot(old_eic_Met)
eic_Met <- chromatogram(data,  mz = Met_mz + c(-0.05, 0.05), rt = c(175, 195))
plot(eic_Met)
```
Our test ions did not display any significant differences between the raw and 
adjusted data. 

Use another ion as example...

## Correspondence

- use *bad* settings (check maybe xcmsTutorials for examples)

```{r}
#' Default parameter for the grouping and apply them to the test ions BPC 
pdp <- PeakDensityParam(sampleGroups = sampleData(data)$phenotype, bw = 30)
plotChromPeakDensity(chr_1, param = pdp)


#'Now apply them to creatine / or another ions that shows it
#'
#'Updating parameters
pdp <- PeakDensityParam(sampleGroups = sampleData(data)$phenotype,
                        minFraction = 1/3, binSize = 0.015, bw = 2.3)

#' Apply to creatine 

```

- Good settings 

```{r}
#' Now apply to whole data
data <- groupChromPeaks(data, param = pdp)

data <- fillChromPeaks(data, param = ChromPeakAreaParam(), chunkSize = 5)

```

## Gap filling

- compare signal for filled-in and detected signal for QC samples. is it
  correlated?
  
  
These pre-processing steps results in the two-dimensional matrix with abundances
of the so-called LC-MS features in all samples. At this stage the features are 
only characterized by their m/z and retention time. 
  

# Data normalization

- between sample normalization
- maybe skip signal drift normalization
- Evaluation on IS.

# Identification of interesting features

- Pre-filtering.
- Differential abundance.

Task: sensitivity analysis: with/without normalization. with/without
pre-filtering.


# Annotation

- Different levels of annotation.
- Just m/z (mass).
- m/z and retention time.
- MS/MS spectra + public repository.
- MS/MS spectra + retention time.

# Summary

# Session information

# References

