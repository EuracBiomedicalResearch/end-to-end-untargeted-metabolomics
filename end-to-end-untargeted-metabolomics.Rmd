
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```
# Abstract 

Untargeted Ms/MS analysis has... (one sentence intro on the technic). 
Currently, numerous specialized packages cater to specific analysis steps but 
often lack flawless integration. Here, we introduce an R pipeline leveraging 
*Spectra* and *MsExperiment* to encompass all pre-processing and downstream 
analyses of LC-MS/MS datasets in a reproducible manner. Our pipeline seamlessly
integrates Bioconductor packages, offering adaptability to diverse study designs
and analysis requirements.

# Keyword
LC-MS/MS, Preprocessing, normalization, feature identification... 

# Introduction

- Relevancy of the technic
- Challenges (explaining the need for seamless integragration and overall pipeline)
- Thus we propose a highly-detailed and adaptable pipeline for LC-MS/MS data analysis. 
Comprised of preprocessing steps based on the *xcms* package, which is highly 
adaptable to dataset-specific requirement... 

# Data description

The data represents a subset of samples from a larger experiment and consists of
in total 10 mzML files with 3 samples from individuals with 
arrhymogenic cardiomyopathie (AOC) a cardiovascular disease, 3 samples from 
healthy donors and 4 QC samples (pool of all samples of the experiment). 
The MS data has been restricted to a retention time range from
20 to 230 seconds and an m/z range from 0 to 500 (it has not but should i ?. 

NEEEDS UPDATE!
The data and metadata used in this workflow can be found on the masssive database under the ID: 


# Workflow description 

This pipleine here describes all steps required to preprocess and assign features identity to LC-MS/MS data. It is performed thanks to the *MsExperiment* and *PSpectra* packages that integrate multiple Bioconductor packages for LC-MS/MS analysis.
The preprocessing steps are performed using the *xcms* packages and consist of Chormatogrphic peak detection, retention time alignment and Correspondence. 
- where to put the *MetaboCoreUtils* package info 
The preprocessing of the data is then followed by normalization, identification of features and lastly annotation of these features. 
Laslty, *RColorBrewer*, *pander*, and *pheatmap* were used for data visualization.

Our workflow is therefore based on the following dependencies: 

```{r packages used}
library(MsExperiment)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(MetaboCoreUtils)
library(pheatmap)
```

# Data import

The *mzML* files with the raw MS data are located within the *data/mzML* folder
of this repository. [ideally, they should be added and then downloaded from
MassIVE].

```{r}
#' read the sample descriptions from an xlsx sheet
pd <- as.data.frame(read_xlsx("data/phenodata.xlsx"))

#' Import the data

#' Massive data bank extraction but for now not. 
MZML_PATH <- "C:/Users/plouail/OneDrive - Scientific Network South Tyrol/end-to-end_worflow/data/mzML"

#' register(MulticoreParam(6)) ask johannes about that
data <- readMsExperiment(paste0(MZML_PATH, "/", pd$mzML_file) ,sampleData = pd)
```
...

```{r}
#' Set up parallel processing using 2 cores
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(2)))
} else {
    register(bpstart(SnowParam(2)))
}
```

# Data organisation

```{r}
data
```

The experimental data is now a 'MsExperiment' object.  The 'MsExperiment' object manages the linkage between samples and spectra 
  - it's length is defined by the number of samples within the object. 


The phenodata is a crucial aspect of LC-MS/MS analysis. Table 1 here shows us 
more details about our dataset's samples.

There is 'r length(sampleData(data))' samples in this dataset. Here are some 
abbreviation necessary to properly read the phenodata table.
- Injection Index:
- QC: Quality control sample 
- CVD: 
- CTR: 

Metadata in our 'MsExperiment' object is accessed using the 'sampleData()' function. we used this and the 'pander' package to build this table representing the metadata of our study (table 1)

```{r phenodata, echo=FALSE}
print("Table 1.Samples from the data set.")
data |>
  sampleData() |> 
  as.data.frame() |>
  pandoc.table(style = "rmarkdown", caption = "Samples from the data set.", )
```

```{r define-colors, include=FALSE}
#' Define colors for the groups.
col_phenotype <- brewer.pal(4, "Set1")[c(2, 1, 4)]
names(col_phenotype) <- c("CTR", "CVD", "QC")

col_sample <- col_phenotype[sampleData(data)$phenotype] 
```


The MS data of this experiment is stored as a 'Spectra' object within the 
'MsExperiment' object and can be accessed using 'Spectra()' function. 
Each element in this object is a spectrum - they are organised linearly and are 
all combined in the same 'spectra' object one after the other (through retention
time and samples).
```{r}
# Access Spectra Object 
spectra(data)
```
  
```{r}
# Check number of samples 
length(data)
```

We therefore have an dataset of 'r length(spectra(data))' spectra. 

```{r}
#' Retention time range for entire dataset 
spectra(data) |>
rtime() |>
range()
```
Data coming from LC-MS experiments are usually analyzed along the retention time
axis. MS data is organized by spectrum and hence orthogonaly to the retention 
time axis. The 'chromatogram()' function therefore allows to extract intensities
along retention time. The access to chromatographic information is not as 
efficient and seamless as for spectra information but development of a 
'chromatogram' object as thorough and easy of use as the 'Spectra' object is 
underway. 

# Data visualization and general quality assessment

Visualization is crucial for inspection and quality assessment of MS data. 
To generate general overview of our LC-MS/MS we can: 
- Combine all spectra measured into one single spectrum = Base peak spectrum 
- Aggregate peak intensity for each spectrum (scan) = Base peak chromatogram, 
which is orthogonal to the BPS
  
## Visualisation fo spectra data 

BPS collapses data in the retention time dimension. such visualisation provides information on the most abundant mass-to-chagre values (m/z) ub the data set regardless of the rtime in whihc th were measured. Compared to the BPC, BPS visualization is not as straightforward. Indeed, mass peaks, even if representing signal from the same ion, will never be identical between consecutive spectra, but will slightly differ based on the measurement error/resolution of the instrument. 
```{r bps }
bps <- combineSpectra(spectra(data), f = fromFile(data),
                      intensityFun = max, ppm = 10) #increase ppm ? 

#' show all the bps, but takes so long 
for (i in 1:length(bps)){
  plotSpectra(bps[i])
}

#' Filter the data based on mz ?
```

These BPS thus show the most common ions present in each of the samples. There 
seem to be some overlap in ion content between the files (around 300 m/z and 
700 m/z), but also some quite distinct signals.

It is also highly suggested to explore the data in more details. This can easily be done by assessing our data extracting spectrum/region of interest.
```{r }
#' Accessing a single spectrum 
exspec <- spectra(data[1])[100]
plotSpectra(exspec)
```

We can then explore details about this specific spectra by using a wide range 
of functions:
```{r}
#' checking its intensity 
intensity(exspec)

#' checking its rtime 
rtime(exspec)

#' Checking its m/z 
mz(exspec)
```

We can focus on a specific subset of the data at a specific rtime range and then
look at all the spectrum there 

```{r}
#' subsetting for retention time 
exspec <- spectra(data) |> 
  filterRt(c(180,181))

#' subsetting for rtime in 2 QC samples
#' here not sure what to show, 4 samples is already too many
exspecQC <- data[c(1,4,7,10)] |>
  filterMz(c(105,120)) |> #do something like this ?
  spectra() |> 
  filterRt(c(180,181))
exspecQC

plotSpectra(exspecQC[1:4]) 
```

There were 'r length(exspec)' spectra measured in this one second within the 
entire dataset and 'r length(exspecQC)' in our QC samples. After plotting them, 
we can spot several mass peaks, a common peak can be seen at 106 m/z which could
represent the ion of Serine. We can look into this a bit later.


## Chromatogram data and heatmaps to evaluate LC performance.

For LC-MS data visualizing, a base peak chromatogram (BPC) or total ion 
chromatogram (TIC) would for example allow to evaluate the performance of the 
liquid chromatography of the various samples in an experiment. To create such a 
plot we below extract the BPC from our data. The BPC extracts the maximum peak 
signal from each spectrum in a data file and plots this information 
(on the y-axis) against the retention time for that spectrum. The BPC can be 
extracted using the 'chromatogram' function. 
With parameter 'aggregationFun = "max"' we define to report the maximum signal 
per spectrum. On the other hand setting 'aggregationFun = "sum"' sum up all 
intensities of a spectrum and hence create a TIC.

```{r bpc}
#' First extract and plot bpc for full data
bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

#' Filter the data based on retention time plot again
data <- filterRt(data, c(10, 240))
bpc <- chromatogram(data, aggregationFun = "max")
plot(bpc, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
```
We first looked through the entire base peak chromatogram and then filtered it 
with specific retention time this allows to get smaller file size and an easier
to read bpc. 

This last plot hence shows th BPC for each samples and give us information on 
the retention time captured during our experiment, therefore at what retention 
time compounds eluted fron the LC column. Essentially, a BPC collapses the 
3-dimensional LC-MS data (m/z by retention time by intensity) into 2 dimensions 
(retention time by intensity)
  
```{r heatmap}
bpcb <- bin(bpc)
intmat <- do.call(cbind, lapply(bpcb, intensity))
simmat <- cor(intmat)
pheatmap(simmat, show_rownames = TRUE) # not really sue why there is no axis.
#' improve this labelling 

#' Total ion chromatogram - and heatmap 
tic <- chromatogram(data, aggregationFun = "sum")
plot(tic,col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)
btic <- bin(tic)
ticmap <- do.call(cbind, lapply(btic, intensity))
sticmap <- cor(ticmap)
pheatmap(sticmap)
```


## XIC of internal standards.

Calculate the mass of a few ion expected to be seen in the dataset.
- then calculate the ion mass for these - create a variable in which you put it
- use this variable to subset MS data for all ion with this mass - check the chromatogram for this range (take in note the rtime range)
Next need to generate extracted ion chromatogram (XIC) for all these "test ions" 

```{r}
#'Calculating ion mass for Serine
mass_serine <- calculateMass("C3H7NO3")
serine_mz <- mass2mz(mass_serine, "[M+H]+")
serine_mz <- serine_mz[1, 1]

#' More refined XIC from QC samples 
chr_serine <- (chromatogram(data[c(1,4,7,10)], rt = c(164, 200),
                           mz = serine_mz + c(-0.05, 0.05),
                           aggregationFun = "max"))
plot(chr_serine)

#' Also show another XIC that is less obvious (glycine or something else that has 2 distinct peak)

#mass_ <- calculateMass("C3H7NO3")
#_mz <- mass2mz(mass_, "[M+H]+")
#_mz <- _mz[1, 1]

#' More refined XIC from QC samples 
#chr_ <- (chromatogram(data[c(1,4,7,10)], rt = c(164, 200),
                          # mz = _mz + c(-0.05, 0.05),
                           #aggregationFun = "max"))
#plot(chr_)

# put all samples, but keep the colours



#' under here is test  to analyse multiple ions at the same time, however i am 
#' struggling a bit with the fact that they have a wide range of rtime and 
#' therefore make downstream analysis less clear for people. 
#' either need to be improve, change ions of interest or just do one ion by one. 
#' the code works though 

#' first create a data.frame that will store the compound of interest and their
#' calculated ion mass
well_known <- data.frame(
  row.names = c("serine", "glycine", "creatine", "glucose"))
well_known$Formula <- c("C3H7NO3", "C2H5NO2", "C4H9N3O2", "C6H12O6")
well_known$Mass <- calculateMass(well_known$Formula)
well_known$mz <- mass2mz(well_known$Mass, "[M+H]+")

#create a list of chromatogram in the QC samples for all the compound 
list_names <- row.names(well_known)
chr_list <- list()
for (i in 1:length(well_known$mz)) {
  print(i)
  chr_names <- paste0("chr_" , list_names[i])
  chr <- chromatogram(data[c(1,4,7,10)], rt=c(25, 185), 
                      mz = well_known[i,3] + c(-0.05, 0.05)) 
  chr_list[[chr_names]] <-  chr
  plot(chr_list[[chr_names]], main = chr_names)
}
# sodium 

```

These well-known ions can be used later for pre-processing

# Data pre-processing

Preprocessing is the first step in the analysis of untargeted LC-MS or gas 
chromatography (GC)-MS data. The aim of the preprocessing is the quantification
of signals from ions measured in a sample, adjusting for any potential retention
time drifts between samples and the matching of the quantified signal across 
samples within an experiment. ..

## Chromatographic peak detection

use the findChromPeaks function within xcms
- the preferred algorithm is the CentwaveParam - better for non-Gaussian shape which is what we usually get with HILIC separation (other algorithm also exist)

```{r}
#' Use default Centwave parameter, and evaluate for serine. 
cwp <- CentWaveParam()
default <- findChromPeaks(chr_serine, param= cwp)
chromPeaks(default)

#' do same with second chosen ion

#' With more accurate parameters 
cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 40, integrate = 2)
chr_serine_test <- findChromPeaks(chr_serine, param= cwp)
chromPeaks(chr_serine_test)
plot(chr_serine_test)

#' do same with second chosen ion
#' 


##' Here again test for multiple ions at once, works but again bc rtime is so different, cannot see super clearly
#' Evaluate signal for common ions
#' use the previously build list of XIC for common ions 
cwp <- CentWaveParam()
defaultrun <- findChromPeaks(chr_list[[1]], param = cwp )
chromPeaks(defaultrun)

cwp <- CentWaveParam(peakwidth = c(2, 10), ppm = 40, integrate = 2)
list_names <- row.names(well_known)
for (i in 1:length(chr_list)) { 
  print(i)
  chr_names <- paste0("chr_" , list_names[i])
  batch_chr  <- findChromPeaks(chr_list[[i]], param = cwp )
  print(chr_names)
  print(chromPeaks(batch_chr))
  plot(batch_chr, main = chr_names)
}


```

- re-run with adapted settings.

```{r run find chrompeak on entire dataset}

data <- findChromPeaks(data, param = cwp, chunkSize = 5)
data

#' Test if we find serine again 
xic_serine <- chromatogram(data, mz = c(106.04, 106.06),
                           rt = c(170, 186))
chromPeaks(xic_serine) 
plot(xic_serine, main = "XIC serine with identified chromatographic peaks")

#' same wiht second chosen ion 

```
These chrompeask can also be seen in generic plots such as below: 
```{r}
srn <- data |>
filterRt(rt = c(175, 188)) |>
filterMz(mz = c(106.04, 106.06))

plot(srn[1])
```

### Refine chromatographic peaks 

The identification of chromatographic peaks can sometimes lead to peak detection 
artifacts, either overlapping or splits. The function 'refineChromPeaks' is used
in this case in combination with the 'MergeNeighboringPeaksParam'. 
This function will results in either removing of peaks that do not meet the 
condition stated in the parameter or merge peaks that were artificially split 
in the previous step. 

```{r merging }

#' set up the parameter 
mnpp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                   minProp = 3/4) 

#' Apply on whole dataset
data_pp <- refineChromPeaks(data, param = mnpp, chunkSize = 5)
chromPeakData(data_pp)

#' check how it went
#' struggling to find an area to check here # backtrack using the chrompeaksdata 

par(mfrow = c(1, 2))
plotChromPeaks(data, 1)
plotChromPeaks(data_pp, 1)


#' if all good replace data by the merged data 
data <- data_pp



```

## Retention time alignment

- use initial correspondence.

Let's buildlook at the bpc again: 
```{r}
bpc_raw <- data |>
  chromatogram(aggregationFun = "max")

plot(bpc_raw, peakType = "none", col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)

#change color of non QC so they are less visible 
```

Here we can see that the QC samples that were measured with the same setup on 
the same day show a slight drifts of the signal are visible.

```{r}

# Grouping the peaks according to 
pdp <- PeakDensityParam(sampleGroups = sampleData(data)$phenotype,
                        minFraction = 0.75,
                        binSize = 0.01,
                        bw = 2)
data <- groupChromPeaks(data, param = pdp)



#' Define parameters of choice
pgp <- PeakGroupsParam(minFraction = 0.9, extraPeaks = 50, span = 0.3,
                       subsetAdjust = "average",
                       subset = which(sampleData(data)$phenotype == "QC"))

#' Input in the function
data <- adjustRtime(data, param = pgp)

#' See result
plotAdjustedRtime(data, col = paste0(col_phenotype[bpc$phenotype], 80))
grid()
legend("topright", col = col_phenotype,
       legend = names(col_phenotype), lty = 1)


```

```{r bpc before and after}
par(mfrow = c(2, 1))
#' Plot the raw base peak chromatogram
data_raw <- dropAdjustedRtime(data)
plot(bpc_raw, peakType = "none")
#' Plot the BPC after alignment
plot(chromatogram(data, aggregationFun = "max", chromPeaks = "none"))
```


- use subset alignment.

```{r specific ion before and after}
#' Similar comparison but this time filtering to see specific ion
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
chromatogram(data_raw, mz = c(106.04, 106.06), rt = c(170, 186)) |>
plot()

#' Extract the bpc for serine after the adjusted time 
bpc_serine <- chromatogram(data,  mz = c(106.04, 106.06), rt = c(170, 186))
plot(bpc_serine)


#add the second ion 
```

## Correspondence

- use *bad* settings (check maybe xcmsTutorials for examples)

```{r}
#' Use creatine here as a bad example ? 
#' Default parameter for the grouping 
#' Apply them to the serien BPC 
#' 
#'Now apply them to creatine / or another ions that shows it
#'
#'Updating parameters
pdp <- PeakDensityParam(sampleGroups = sampleData(data)$phenotype,
                        minFraction = 1/3, binSize = 0.015, bw = 2.3)

#' Apply to creatine 

```

- Good settings 

```{r}
#' Now apply to whole data
data <- groupChromPeaks(data, param = pdp)

data <- fillChromPeaks(data, param = ChromPeakAreaParam(), chunkSize = 5)

```

## Gap filling

- compare signal for filled-in and detected signal for QC samples. is it
  correlated?
  
  
These pre-processing steps results in the two-dimensional matrix with abundances
of the so-called LC-MS features in all samples. At this stage the features are 
only characterized by their m/z and retention time. 
  

# Data normalization

- between sample normalization
- maybe skip signal drift normalization
- Evaluation on IS.

# Identification of interesting features

- Pre-filtering.
- Differential abundance.

Task: sensitivity analysis: with/without normalization. with/without
pre-filtering.


# Annotation

- Different levels of annotation.
- Just m/z (mass).
- m/z and retention time.
- MS/MS spectra + public repository.
- MS/MS spectra + retention time.

# Summary

# Session information

# References

