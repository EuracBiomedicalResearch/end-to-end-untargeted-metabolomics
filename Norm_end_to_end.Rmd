---
title: "Norm_end_to_end"
author:
  - name: "Philippine Louail"
affiliation: "Eurac Research, Bolzano, Italy"
output: html_document
date: "2023-09-07"
---

```{r style, message = FALSE, echo = FALSE, warning = FALSE, results = "asis"}
library("BiocStyle")
library("knitr")
library("rmarkdown")
opts_chunk$set(message = FALSE, error = FALSE, warning = FALSE,
               cache = FALSE, fig.width = 7, fig.height = 7)
```


```{r packages used}
library(MsExperiment)
library(xcms)
library(Spectra)
library(RColorBrewer)
library(pander)
library(readxl)
library(MetaboCoreUtils)
library(pheatmap)
library(DESeq2)
library(CompMetaboTools)
library(ggplot2)
library(ggfortify)
```

## Initial quality assessment

First need to load the results and the preprocessed dataset. We also create a
new `assay` within the result object and impute the `NA` values.
In this analysis, all metabolites are considered. We
assume that most missing values (i.e. those not removed because of technical
problems) are representing signal which is below detection limit. In such cases,
missing values are replaced with random numbers from the uniform distribution
from the half of smallest measured value to the smallest measured value for that
analyte.  The uniform distribution is defined with two parameters (minimum and
maximum) and all values between them have an equal probability of being
selected.

```{r}
#' Load preprocessing results
load("SumExp.RData")
load("data.RData")

#' Define colors for the groups.
col_phenotype <- brewer.pal(8, name = "Dark2")[c(8, 4, 3)]
names(col_phenotype) <- c("QC",
                          "CVD",
                          "CTR")
col_sample <- col_phenotype[res$phenotype]

#' Impute missing values:
na.unidis <- function(z) {
    na <- is.na(z)
    if (any(na)) {
        min = min(z, na.rm = TRUE)
        z[na] <- runif(sum(na), min = min/2, max = min)
    }
    z
}

tmp <- apply(assay(res, "raw_filled"), MARGIN = 1, na.unidis)

assays(res)$raw_filled_imputed <- t(tmp)

#' Also one assay where just remove NAs For the PCA
naomit <- assay(res, "raw_filled") |>
    na.omit()
```

### PCA unsupervised

Look for overall biases in batch, sample, injection index,...

```{r unsupervised checks, include=TRUE, fig.width = 10, fig.height = 5}
## note: scale (center and scale) on columns (features after the t() call) to
## remove dependency on absolute abundances.
vals <- assay(res, "raw_filled_imputed") |>
    log2() |>
    t() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)

## - clear separation of study (plasma) from QC Pool (serum) on PC1.
## - separation based on phenotype on PC3.
## - no relationship of PC1 to PC4 on injection index.

## PCA without any imputed values to check PCA is not driven by imputation.
vals <- naomit |>
    log2() |>
    t() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)

## Results are similar, thus, imputation did not affect PCA; we can drop
## that PCA.

```

### Intensity evaluation

Counts of non missing values and feature abundance distribution

```{r counts, include=TRUE}
layout(mat = matrix(1:3, ncol = 1), height = c(0.2, 0.2, 0.8))

par(mar = c(0.2, 4.5, 0.2, 3))
barplot(apply(assay(res, "raw"), MARGIN = 2, function(x) sum(!is.na(x))),
        col = col_sample, ylab = "features", xaxt = "n", space = 0.012)
barplot(apply(assay(res, "raw_filled"), MARGIN = 2, function(x) sum(!is.na(x))),
        col = col_sample, ylab = "features", xaxt = "n", space = 0.012)
boxplot(log2(assay(res, "raw_filled")), xaxt = "n", ylab = "log2 abundance",
        col = col_sample, outline=FALSE, medlty = "blank", border = col_sample,
        boxwex = 0.99 )
points(colMeans(log2(assay(res, "raw_filled")), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
```


RLA

```{r rla-plot raw and filled, fig.cap = "RLA plot for the raw data and filled data. Note: outliers are not drawn."}
par(mfrow = c(1, 1), mar = c(0.2, 4.5, 2.5, 3))
boxplot(rowRla(assay(res, "raw_filled"), group = res$phenotype),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "Filled in data", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

## Note: with group = res$phenotype we show relative abundances of each sample
## against the other samples of the SAME group. This does thus allow to
## evaluate how different/similar the signal distribution of samples within
## the same group are. What we see here:
## Medians for most samples are centered around 0. Exception is one of the
## red samples. But normalization (hopefully) helps there.
```

### Internal standard

We want to select the internal standard for which we have features defined.

```{r include=TRUE}
#' get the list
intern_standard <- read.delim("internal_standards.txt")
intern_standard <- intern_standard[!is.na(intern_standard$POS), ]

#'generate calculate formula
intern_standard$mz <- mapply(intern_standard$formula, intern_standard$POS,
                             FUN = mass2mz)

intern_standard$feature_id <- NA_character_

library(MetaboAnnotation)
#' identify features matching m/z and RT of internal standards. With
#' mzColname and rtColname we specify the column names in query and target
#' that contain the m/z or RT values.
fdef <- featureDefinitions(data)
fdef$feature_id <- rownames(fdef)
match_intern_standard <- matchValues(
    query = intern_standard,
    target = fdef,
    mzColname = c("mz", "mzmed"),
    rtColname = c("RT", "rtmed"),
    param = MzRtParam(ppm = 50, toleranceRt = 10))

#' keep only matches with a 1:1 mapping standard to feature, i.e.
#' remove matches for standards mapping to more than one feature
rem_dups <- function(x) {
    if (nrow(matches(x)) > 1)
        filterMatches(x, index = integer())
    else x
}
match_intern_standard <- endoapply(match_intern_standard, FUN = rem_dups)
intern_standard$feature_id <- match_intern_standard$target_feature_id

intern_standard <- intern_standard[!is.na(intern_standard$feature_id), ]

is_features <- featureChromatograms(
    data, features = intern_standard$feature_id, expandRt = 5)

dr <- file.path("png", "internal_standard", "features", "IS_feature_for")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
for (i in seq_len(nrow(intern_standard))) {
    png(paste0(dr, "/", intern_standard[i, "abbreviation"], ".png"),
        width = 16, height = 8, units = "cm", res = 200, pointsize = 4)
    eic <- is_features[i, ]
    plot(eic, col = col_sample,
         peakBg = paste0(col_sample[chromPeaks(eic)[, "sample"]], 40))
    abline(v = intern_standard$RT[i], lty = 2)
    dev.off()
}

#' prepare PCA; maybe remove later?
vals <- naomit[intern_standard$feature_id, ] |>
    log2() |>
    t() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)

```

Describe distribution of IS..

```{r internal-standard-table, include=TRUE, results = "asis"}
#' table of internal standards with mean and sd of abundances (in log2 scale)
tmp_fv <- assay(res, "raw_filled")[intern_standard$feature_id, ]
intern_standard$mean_abd <- rowMeans(log2(tmp_fv), na.rm = TRUE)
intern_standard$sd_abd <- rowSds(log2(tmp_fv), na.rm = TRUE)
intern_standard$CV_raw <- rowRsd(tmp_fv, na.rm = TRUE)

cpt <- paste("Internal standards with detected and assigned features, mean and",
             "standard deviation of (log2) abundance and RSD.")
pandoc.table(intern_standard[, c("name", "mean_abd", "sd_abd", "CV_raw")],
             style = "rmarkdown", caption = cpt)
```

## Between sample normalisation

Implement between-sample normalization using filled-in features. This process
effectively mitigates variations influenced by technical issues, such as
differences in sample preparation and injection methods. In this case we will
test different method that are commonly used in metabolomics.

### Median scaling

compute the median for each sample, followed by determining the median of these
individual sample medians. This ensures consistent median values for each sample
throughout the entire dataset. Maintaining uniformity in the average total
metabolite abundance across all samples is crucial for effective implementation.

This process aims to establish a shared baseline for the central tendency of
metabolite abundance, mitigating the impact of sample-specific technical
variations. This approach fosters a more robust and comparable analysis of the
top features across the dataset. The assumption is that normalizing based on
the median, known for its lower sensitivity to extreme values, enhances the
comparability of top features and ensures a consistent average abundance across
samples.

```{r}
#' Compute median and generate normalization factor
mdns <- apply(assay(res, "raw_filled"), MARGIN = 2,
              median, na.rm = TRUE )
nf_mdn <- mdns / median(mdns)
#' divide dataset by median of median
assays(res)$median_filled <- sweep(assay(res, "raw_filled"), MARGIN = 2, nf_mdn,
                                   '/')
```

- run median scaling for top 500 features per samples

This method is motivated by the higher likelihood that the 500 top features for
each sample should exhibit a similar average total metabolite abundance across
all samples.

```{r}
# Get the top 500 features for each column
top_500 <- apply(assay(res, "raw"), MARGIN = 2,
                 function(x) x[order(x, decreasing = TRUE)][1:500])

#' Compute median and generate normalization factor
mdns <- apply(top_500, MARGIN = 2, median )
nf_mdn <- mdns / median(mdns)
#' divide dataset by median of median
assays(res)$median_filled_500 <- sweep(assay(res, "raw_filled"),
                                       MARGIN = 2, nf_mdn, '/')
```


### Methods based on IS

In our evaluation, we will assess the performance of two normalization methods:
RUV, which relies on internal standards or metabolites correlating with their
abundance to estimate technical variance, and NOMIS, a method that normalizes
features based on their best internal standard.

RUV aims to eliminate variance using the signal from negative control
features —features known to remain constant between conditions. This method
requires prior knowledge of metabolites that do not change between samples but
does not necessitate QC samples. One proposed approach is to select all
metabolites with a correlation coefficient greater than 0.6 to the average of
internal control compounds, as suggested by De Livera et al. An important
consideration is that the RUV method cannot be applied before unsupervised
clustering methods.

```{r ruv-norm-define-ctrls, message = FALSE, warning = FALSE}
#' Maybe we should do this only on values for study samples - since the
#' QC (Pool) is not really representative. Thus, the features we're picking
#' here and the variance we're removing then is mostly differences between
#' QC (serum) and study (plasma).
fts_int_std_mean <- colMeans(assay(res, "raw")[intern_standard$feature_id, ],
                             na.rm = TRUE)

cor_int_std <- apply(log2(assay(res, "raw")),
                     MARGIN = 1, cor, y = log2(fts_int_std_mean))

neg_ctrls <- which(cor_int_std > 0.6)
neg_ctrls_int <- which(rownames(res) %in% intern_standard$feature_id)
```

RUV comes in various flavors, with this evaluation using the RUV-rand method
and RUVIII, which incorporates replicate information. It's important to avoid
variants like RUV-2 before PCA or other unsupervised clustering approaches.
Also, note that RUV does not accept missing values, necessitating the
normalization on the imputed dataset.

```{r ruvs, message = FALSE, results = "hide"}
library(MetNorm)

ruv_rand <- NormalizeRUVRand(t(log2(assay(res, "raw_filled_imputed"))),
                             ctl = neg_ctrls_int, k = 5,
                             plotk = FALSE)
fv_ruvr <- 2^t(ruv_rand$newY)
assays(res)$ruvr <- fv_ruvr

library(ruv)
ruv_3 <- RUVIII(t(log2(assay(res, "raw_filled_imputed"))),
                ctl = neg_ctrls_int, k = 5,
                M = design.matrix(res$sample_name))
fv_ruv3 <- 2^t(ruv_3)
assays(res)$ruv3 <- fv_ruv3
```

NOMIS

It's essential to note that this method requires a filled-in and imputed dataset
as it does not allow missing values.

Also been archived since 2020

```{r nomis, warning = FALSE, message = FALSE}
#' Use the NormalizeMets package
library(NormalizeMets)
fv_nms <- 2^t(NormQcmets(
                t(log2(assay(res, "raw_filled_imputed"))), method = "nomis",
                qcmets = which(rownames(res) %in% intern_standard$feature_id)
            )$featuredata)
#' re-add the internal standards!
fv_nms <- rbind(
    fv_nms,
    assay(res, "raw_filled_imputed")[intern_standard$feature_id, ])
fv_nms <- fv_nms[rownames(res), ]
assays(res)$NOMIS <- fv_nms
```

About the archived thing - For now using the packages, if
decide it's good enough, we can maybe rewrite the code (addition to the
externalTools package that we thought about ? or a specialized MsNorm package)
or something and reference them ?

### Evaluate and select *best* norm method

#### Coefficient of variation

coef of variation of QC samples should go down

```{r include=TRUE, results = "asis"}
index_QC <- res$phenotype == "QC"

QC <- cbind(
    CV_Raw = rowRsd(assay(res, "raw_filled")[, index_QC], na.rm = TRUE),
    CV_MRM = rowRsd(assay(res, "median_filled")[, index_QC], na.rm = TRUE),
    CV_MRM_500 = rowRsd(
        assay(res, "median_filled_500")[, index_QC], na.rm = TRUE),
    CV_ruvr = rowRsd(assay(res, "ruvr")[, index_QC], na.rm = TRUE),
    CV_ruv3 = rowRsd(assay(res, "ruv3")[, index_QC], na.rm = TRUE),
    CV_NOMIS = rowRsd(assay(res, "NOMIS")[, index_QC], na.rm = TRUE)
)

#' Number <0.3
QC_summary <- matrix(ncol= ncol(QC), dimnames = list("CV <0.3"))
for (i in seq_len(ncol(QC))){
    QC_summary["CV <0.3",i] <- sum(QC[, i] < 0.3, na.rm = TRUE)
}
colnames(QC_summary) <- colnames(QC)
QC_summary
#' Realized that Anne did the mean RSD, could combine it in this table
#' actually could make this table combined with the study sample also. for
#' better comparison

#' Quantile
QC_df <- data.frame(raw = quantile(QC[, "CV_Raw"], na.rm = TRUE),
                    MRM = quantile(QC[, "CV_MRM"], na.rm = TRUE),
                    MRM_500 = quantile(QC[, "CV_MRM_500"], na.rm = TRUE),
                    ruvr = quantile(QC[, "CV_ruvr"], na.rm = TRUE),
                    RUVIII = quantile(QC[, "CV_ruv3"], na.rm = TRUE),
                    NOMIS = quantile(QC[, "CV_NOMIS"], na.rm = TRUE)
                    )
cpt <- paste0("Distribution of CV values across QC samples for the raw ",
              "and between-sample normalized data.")
pandoc.table(QC_df, style = "rmarkdown", caption = cpt)
```

coef of variation of IS should go down

```{r include=TRUE, results = "asis"}
intern_standard$CV_MRM <- rowRsd(
    assay(res, "median_filled")[intern_standard$feature_id, ], na.rm = TRUE)
intern_standard$CV_MRM_500 <- rowRsd(
    assay(res, "median_filled_500")[intern_standard$feature_id, ], na.rm = TRUE)
intern_standard$CV_ruvr <- rowRsd(
    assay(res, "ruvr")[intern_standard$feature_id, ], na.rm = TRUE)
intern_standard$CV_ruv3 <- rowRsd(
    assay(res, "ruv3")[intern_standard$feature_id, ], na.rm = TRUE)
intern_standard$CV_NOMIS <- rowRsd(
    assay(res, "NOMIS")[intern_standard$feature_id, ], na.rm = TRUE)

cpt <- paste("Internal standards with detected and assigned features coefficient
             of variation before and after different method of normalization.")
pandoc.table(intern_standard[, c("abbreviation", "CV_raw", "CV_MRM",
                                 "CV_MRM_500", "CV_ruvr",
                                 "CV_ruv3", "CV_NOMIS")],
             style = "rmarkdown", caption = cpt)
```

At first glance it seems that MRM 500 works better than MRM. and RUV random
completely remove variation.. . RUV and NOMIS used however the internal
standards to estimate noise (correct?), thus, it would be expected that CV
of internal standards decreases considerably for these methods.

Estimating the CV for internal standards only in study samples - to avoid any
influence from QC samples.

```{r include=TRUE, results = "asis"}
index_study <- which(res$phenotype != "QC")

is_study <- data.frame(
    CV_raw = rowRsd(assay(res, "raw_filled")[intern_standard$feature_id,
                                              index_study], na.rm = TRUE),
    CV_MRM = rowRsd(assay(res, "median_filled")[intern_standard$feature_id,
                                                 index_study], na.rm = TRUE),
    CV_MRM_500 = rowRsd(
        assay(res, "median_filled_500")[intern_standard$feature_id,
                                        index_study], na.rm = TRUE),
    CV_ruvr = rowRsd(
        assay(res, "ruvr")[intern_standard$feature_id,
                           index_study], na.rm = TRUE),
    CV_ruv3 = rowRsd(
        assay(res, "ruv3")[intern_standard$feature_id,
                           index_study], na.rm = TRUE),
    CV_NOMIS = rowRsd(
        assay(res, "NOMIS")[intern_standard$feature_id,
                            index_study], na.rm = TRUE)
)
cpt <- paste("Internal standards with detected and assigned features coefficient
             of variation before and after different method of normalization.")
is_study$abbreviation <- intern_standard$abbreviation
pandoc.table(is_study[, c("abbreviation", "CV_raw", "CV_MRM",
                          "CV_MRM_500", "CV_ruvr",
                          "CV_ruv3", "CV_NOMIS")],
             style = "rmarkdown", caption = cpt)
```

Study samples
coeff variation of study samples should not go down too much

```{r include=TRUE, results = "asis"}
index_study <- res$phenotype %in% c("CTR", "CVD")

study_sample <- cbind(
    CV_Raw = rowRsd(assay(res, "raw")[, index_study], na.rm = TRUE),
    CV_MRM = rowRsd(
        assay(res, "median_filled")[, index_study], na.rm = TRUE),
    CV_MRM_500 = rowRsd(
        assay(res, "median_filled_500")[, index_study], na.rm = TRUE),
    CV_ruvr = rowRsd(
        assay(res, "ruvr")[, index_study], na.rm = TRUE),
    CV_ruv3 = rowRsd(
        assay(res, "ruv3")[, index_study], na.rm = TRUE),
    CV_NOMIS = rowRsd(
        assay(res, "NOMIS")[, index_study], na.rm = TRUE)
)

#' Number <0.3
study_summary <- matrix(ncol= ncol(study_sample), dimnames = list("CV <0.3"))
for (i in seq_len(ncol(study_sample))){
    study_summary["CV <0.3",i] <- sum(study_sample[, i] < 0.3, na.rm = TRUE)
}
colnames(study_summary) <- colnames(study_sample)
study_summary

#' Quantile
study_df <- data.frame(
    raw = quantile(study_sample[, "CV_Raw"], na.rm = TRUE),
    MRM = quantile(study_sample[, "CV_MRM"], na.rm = TRUE),
    MRM_500 = quantile(study_sample[, "CV_MRM_500"], na.rm = TRUE),
    ruvr = quantile(study_sample[, "CV_ruvr"], na.rm = TRUE),
    RUVIII = quantile(study_sample[, "CV_ruv3"], na.rm = TRUE),
    NOMIS = quantile(study_sample[, "CV_NOMIS"], na.rm = TRUE)
)
cpt <- paste0("Distribution of CV values across study samples for the raw ",
              "and between-sample normalized data.")
pandoc.table(study_df, style = "rmarkdown", caption = cpt)
```
ruv random does manage to both decrease CV for QC and keep ity normal for study
sample.
But it is really weird how much the QV and IS CV is *too* decreased.

#### RLA

```{r rla-plots evaluate norm method, include=TRUE, fig.cap = "RLA plot for the raw data and different sample normalization method. Note: outliers are not drawn.", fig.width = 5, fig.height = 14}
par(mfrow = c(7, 1), mar = c(0.2, 4.5, 3, 3))

boxplot(rowRla(assay(res, "raw_filled"), group = res$phenotype),
        cex = 0.5, pch = 16, col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, cex.main = 1,
        outline = FALSE, xaxt = "n", main = "Raw data", boxwex = 1)
grid(nx = NA, ny = NULL)
legend("topleft", inset = c(0, -0.2), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(rowRla(assay(res, "median_filled"), group = res$phenotype),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "MRM", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(rowRla(assay(res, "median_filled_500"), group = res$phenotype),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "MRM 500", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(rowRla(assay(res, "ruvr"), group = res$phenotype),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "RUV random", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(rowRla(assay(res, "ruv3"), group = res$phenotype),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "RUV III", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(rowRla(assay(res, "NOMIS"), group = res$phenotype),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "NOMIS", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("bottomleft", inset = c(0, -0.2), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7)
```

#### Boxplot of abundances

```{r boxplots evaluate norm method, include=TRUE, fig.cap = "Boxplots of signal distributions for the raw data and different sample normalization method. Note: outliers are not drawn.", fig.width = 5, fig.height = 14}
par(mfrow = c(6, 1), mar = c(0.2, 4.5, 3, 3))

boxplot(log2(assay(res, "raw_filled")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), notch = TRUE, cex.main = 1,
        outline = FALSE, xaxt = "n", main = "Raw data", boxwex = 1)
grid(nx = NA, ny = NULL)
legend("topleft", inset = c(0, -0.2), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(log2(assay(res, "median_filled")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "MRM", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(log2(assay(res, "median_filled_500")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "MRM 500", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(log2(assay(res, "ruvr")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "RUV random", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(log2(assay(res, "ruv3")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "RUV III", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(log2(assay(res, "NOMIS")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "NOMIS", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("bottomleft", inset = c(0, -0.2), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7)
```

... or better violin plots?

```{r violin evaluate norm method, include=TRUE, fig.cap = "Boxplots of signal distributions for the raw data and different sample normalization method. Note: outliers are not drawn.", fig.width = 5, fig.height = 14}
library(vioplot)
par(mfrow = c(6, 1), mar = c(0.2, 4.5, 3, 3))

vioplot(log2(assay(res, "raw_filled")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), cex.main = 1,
        xaxt = "n", main = "Raw data")
grid(nx = NA, ny = NULL)
legend("topleft", inset = c(0, -0.2), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7)
abline(h = 0, lty=3, lwd = 1, col = "black")

vioplot(log2(assay(res, "median_filled")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), xaxt = "n", main = "MRM", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

vioplot(log2(assay(res, "median_filled_500")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), xaxt = "n",
        main = "MRM 500", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

vioplot(log2(assay(res, "ruvr")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), xaxt = "n",
        main = "RUV random", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

vioplot(log2(assay(res, "ruv3")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), xaxt = "n", main = "RUV III",
        cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")

vioplot(log2(assay(res, "NOMIS")),
        cex = 0.5, col = col_sample, ylab = expression(log[2]~abundance),
        border = paste0(col_sample, 40), xaxt = "n",
        main = "NOMIS", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
legend("bottomleft", inset = c(0, -0.2), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7)
```


### PCA for each

Median scaled

```{r, include=TRUE, fig.width = 10, fig.height = 5}
vals <- apply(assay(res, "median_filled"), MARGIN = 1, na.unidis) |>
    log2() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index, main = "median scaled")
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
```

Median scaled 500

```{r, include=TRUE, fig.width = 10, fig.height = 5}
vals <- apply(assay(res, "median_filled_500"), MARGIN = 1, na.unidis) |>
    log2() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index, main = "median scaled 500")
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
```

RUVR

```{r, include=TRUE, fig.width = 10, fig.height = 5}
vals <- apply(assay(res, "ruvr"), MARGIN = 1, na.unidis) |>
    log2() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index, main = "RUVR")
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
```


RUVIII

```{r, include=TRUE, fig.width = 10, fig.height = 5}
vals <- apply(assay(res, "ruv3"), MARGIN = 1, na.unidis) |>
    log2() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index, main = "RUVIII")
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
```


NOMIS

```{r, include=TRUE, fig.width = 10, fig.height = 5}
vals <- apply(assay(res, "NOMIS"), MARGIN = 1, na.unidis) |>
    log2() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index, main = "NOMIS")
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
```



### Apply to dataset

```{r between-sample-choose-best, eval=FALSE, include=TRUE}
# remove the assay or just rewrite code better as to not actually put the assay
# in the SumExp object

#' create another assay norm removing the filled data.
tmp <- # put here
tmp[is.na(assay(res_pos, "raw"))] <- NA
assays(res_pos)$norm_nofill <- tmp
rm(tmp)

#' once settled on one method, i will change code before and after to match this
```

## Within batch normalization

- remove injection order dependent signal drift
fit feature-wise linear model (y ~ inj_idx) to the (log2 transformed) abundance
data of the QC samples within each batch and comapre the slopes for each feature
between the batches.

Because the Gap filling evaluation showed quite a significant difference in
signal between detected values compared to filled in (especially at low signal).
therefore we will used non-filled values for this next step.

Flags: remove fitted linear models for features for which valid
measurement do not span at least 2/3 of the inject index range or for which the
mean of the absolute residual is larger than 0.5.

 - look for highest abs slope plot

### linear model

```{r}
#' take the log2 of the between sample norm results BUT remove filled in data
tmp <- log2(assay(res, "median_filled_500"))
tmp[is.na(assay(res, "raw"))] <- NA

#' Fit linear model to QC samples only.
qc_lm <- xcms:::rowFitModel(
    y ~ injection_index,
    data = as.data.frame(colData(res)[res$phenotype == "QC", ]),
    y = tmp[, res$phenotype == "QC"],
    method = "lm",
    minVals = 3
)

#' Fit linear model to study samples only. Requires injection index to
#' be independent of any experimental covariate.
study_lm <- xcms:::rowFitModel(
    y ~ injection_index,
    data = as.data.frame(colData(res)[res$phenotype != "QC", ]),
    y = tmp[, res$phenotype != "QC"],
    method = "lm",
    minVals = 4
)

#' Calculate slopes
qc_slps <- vapply(qc_lm, function(z) {
    if (length(z) > 1) {
        coefficients(z)[2]
    } else NA_real_
}, numeric(1))

study_slps <- vapply(study_lm, function(z) {
    if (length(z) > 1) {
        coefficients(z)[2]
    } else NA_real_
}, numeric(1))

par(mfrow = c(1, 1))
xl <- range(c(study_slps, qc_slps), na.rm = TRUE)
plot(study_slps, qc_slps, xlim = xl, ylim = xl, xlab = "study", ylab = "QC")
grid()
abline(0, 1, col = "grey")

#' Set injection index and mean of absolute residual minimum
req_prop <- 2/3
meanmin <- 0.5
#' Calculate flags
flagging <- vapply(qc_lm, flag_model_inj_range, logical(1),
                   min_range = diff(range(res$injection_index)) * req_prop,
                   column = "injection_index")

##' Plot the distribution of slopes.
hist(qc_slps, breaks = 128, xlab = "slope", main = "lm")
hist(qc_slps[which(flagging)], breaks = 128, add = TRUE,
     col = "#0000ff80")

#' Split into excluded and good mdls
mdls_excluded <- qc_lm[which(flagging)]

#' remove model fits for flagged slopes
qc_lm[unique(which(flagging))] <- NA
qc_slps[unique(which(flagging))] <- NA

fts_adj <- sort(unique(
    names(qc_lm)[!is.na(qc_lm)]))
```



The table below lists the number of features for which the model was fitted and
the number of features for which model fitting was skipped or discarded.

```{r fit-model-table, message=FALSE, include=TRUE, results="asis"}
tab <- data.frame(dataset = c(length(qc_lm),
                              length(which(flagging)),
                              sum(!is.na(qc_lm)))
                  )
rownames(tab) <- c("total features", "low inj idx range",
                   "valid model fits")
cptn <- paste("Numbers of features for which an injection index dependent",
              "model could be fitted.")
pandoc.table(tab, style = "rmarkdown", caption = cptn)
```

```{r features-large-slopes-plots, message=FALSE, warning=FALSE, include=TRUE}
#' Plotting all features with an absolute slope larger than some value.
#' Plots are created but not displayed here.
#' Features with absolute slope > 0.025, maybe more ?
dr <- "largest_slopes/above_below_0.025/"
dir.create(dr, showWarnings = FALSE, recursive = TRUE)
fts <- names(qc_lm)[which(abs(qc_slps) > 0.025)]
for (i in fts) {
    png(paste0(dr, i, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot(x = colData(res)$injection_index,
         y = log2(assay(res, "median_filled_500")[i, ]),
         xlim = range(colData(res)$injection_index, na.rm = TRUE),
         ylim = range(log2(assay(res, "median_filled_500")[i, ]), na.rm = TRUE),
         col = col_sample, pch = 16, main = i,
         ylab = expression(log[2]~abundance), xlab = "injection_index")
    abline(qc_lm[[i]], col = col_phenotype["QC"], lty = 2)
    if (length(study_lm[[i]]) > 1)
        abline(study_lm[[i]], col = "red", lty = 2)
    grid()
    dev.off()
}
#' Not super sure about that, would like to discuss
```

```{r include=TRUE}
#' Plot data for features excluded because their data points do not span a
#' large enough portion of the injection range and residual larger than 0.5.
#' take the 20 largest slopes
dr <- "largest_slopes/low_span/"
dir.create(dr, showWarnings = FALSE, recursive = TRUE)
tmp_slps <- vapply(mdls_excluded, function(z) {
    coefficients(z)[2]
}, numeric(1))
fts <- names(sort(abs(tmp_slps), decreasing = TRUE))[1:20]

for (i in fts) {
    png(paste0(dr, i, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot(x = res$injection_index,
         y = log2(assay(res, "median_filled_500")[i, ]),
         xlim = range(colData(res)$injection_index, na.rm = TRUE),
         ylim = range(log2(assay(res, "median_filled_500")[i, ]), na.rm = TRUE),
         pch = 16, col = col_sample,
         main = i, ylab = expression(log[2]~abundance),
         xlab = "injection index")
    abline(mdls_excluded[[i]], col = col_phenotype["QC"], lty = 2)
    grid()
    dev.off()
}
```



```{r}
#' Applying the adjustment to the full (filled-in) data.
tmp <- assay(res, "median_filled_500")
norm_before <- tmp
tmp <- xcms:::applyModelAdjustment(
                             y = log2(tmp), lmod = qc_lm,
                             data = as.data.frame(colData(res)),
                             shiftNegative = "replaceHalfMin")

assays(res)$norm <- 2^tmp
tmp[is.na(assay(res, "raw"))] <- NA
assays(res)$norm_nofill <- 2^tmp

rm(tmp)
```

```{r, include=TRUE, fig.width = 10, fig.height = 5}
vals <- apply(assay(res, "norm"), MARGIN = 1, na.unidis) |>
    log2() |>
    scale(center = TRUE, scale = TRUE)

pca_res <- prcomp(vals, scale = FALSE, center = FALSE)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 4.5, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index, main = "within batch norm")
legend("topleft", inset = c(0, -0.24), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE, ncol = 3,
       cex = 0.7, title = "Phenotype", title.cex = 0.8)
plot_pca(pca_res, pc_x = 3, pc_y = 4, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80),
         labels = res$injection_index)
```



## between batch norm

Eliminate batch-specific effects by considering abundance differences in QC
samples across various batches. Ensure that for each feature, the QC values are
consistent and normalize accordingly. This approach is beneficial for datasets
measured over extended periods or diverse locations.

However, this method is not applicable to the current dataset since there are
no distinct batches as such. Ideally, in the context of a bigger dataset,
batches should each have their own QC samples, allowing inter-batch comparisons
to be conducted using them.

## Assessing overall effectiveness of the normalization approach

### PCA

```{r include=TRUE}
#' Full data before
vals <- assay(res, "raw_filled_imputed") |>
    t() |>
    log2() |>
    scale(center = TRUE, scale = TRUE)
pca_res <- prcomp(vals, scale = FALSE, center = FALSE)
pca_int <- prcomp(vals[, intern_standard$feature_id],
                  scale = FALSE, center = FALSE)

#' Full data after
vals <- apply(assay(res, "norm"), MARGIN = 1, na.unidis) |>
    log2() |>
    scale(center = TRUE, scale = TRUE)
pca_res_norm <- prcomp(vals, scale = FALSE, center = FALSE)
pca_int_norm <- prcomp(vals[, intern_standard$feature_id],
                       scale = FALSE, center = FALSE)

par(mfrow = c(2, 2), mar = c(4, 4, 1, 1))
plot_pca(pca_res, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80))
legend("topleft", col = col_phenotype, legend = names(col_phenotype), lty=1, lwd = 2,
       xpd = TRUE, ncol = 3, cex = 0.7, title = "Phenotype", title.cex = 0.8,
       bty = "n")
title(main = "Full data set PCA before norm", cex = 0.5)
plot_pca(pca_res_norm, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80))
title(main = "Full data set PCA after norm", cex = 0.5)

plot_pca(pca_int, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80))
legend("topleft", col = col_phenotype, legend = names(col_phenotype), lty=1, lwd = 2,
       xpd = TRUE, ncol = 3, cex = 0.7, title = "Phenotype", title.cex = 0.8,
       bty = "n")
title(main = "Internal standard PCA before norm", cex = 0.5)
plot_pca(pca_int_norm, pc_x = 1, pc_y = 2, pch = 21,
         col = col_sample, bg = paste0(col_sample, 80))
title(main = "Internal standard PCA after norm", cex = 0.5)

```

### RLA

```{r rla-plot after norm, include = TRUE, fig.cap = "RLA plot before and after normalization. Note: outliers are not drawn."}
par(mfrow = c(2, 1), mar = c(1, 4, 3, 1))

boxplot(rowRla(assay(res, "raw_filled"), group = res$phenotype),
        cex = 0.5, pch = 16, col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, cex.main = 1,
        outline = FALSE, xaxt = "n", main = "Raw data", boxwex = 1)
grid(nx = NA, ny = NULL)
legend("topleft", inset = c(0, -0.2), col = col_phenotype,
       legend = names(col_phenotype), lty=1, lwd = 2, xpd = TRUE,
       ncol = 3, cex = 0.7, bty = "n")
abline(h = 0, lty=3, lwd = 1, col = "black")

boxplot(rowRla(assay(res, "norm"), group = res$phenotype),
        cex = 0.5, pch = 16,
        col = col_sample, ylab = "RLA",
        border = paste0(col_sample, 40), notch = TRUE, boxwex = 1,
        outline = FALSE, xaxt = "n", main = "After normalization", cex.main = 1)
grid(nx = NA, ny = NULL)
abline(h = 0, lty=3, lwd = 1, col = "black")
```

RSD across QC samples for all features

### CV

In QC samples
```{r include=TRUE, results = "asis"}
index_QC <- res$phenotype == "QC"

QC <- cbind(CV_Raw = rowRsd(assay(res, "raw_filled")[, index_QC], na.rm = TRUE),
            CV_norm = rowRsd(assay(res, "norm")[, index_QC], na.rm = TRUE)
)

#' Number <0.3
QC_summary <- matrix(ncol= ncol(QC), dimnames = list("CV <0.3"))
for (i in seq_len(ncol(QC))){
    QC_summary["CV <0.3",i] <- sum(QC[, i] < 0.3, na.rm = TRUE)
}
colnames(QC_summary) <- colnames(QC)
QC_summary

#' Quantile
QC_df <- data.frame(raw = quantile(QC[, "CV_Raw"], na.rm = TRUE),
                     Norm = quantile(QC[, "CV_norm"], na.rm = TRUE)
                     )
cpt <- paste0("Distribution of CV values across QC samples for the raw ",
              "normalized data.")
pandoc.table(QC_df, style = "rmarkdown", caption = cpt)
```
It increases...

IS
```{r include=TRUE, results = "asis"}
intern_standard$CV_norm <- rowRsd(
    assay(res, "norm")[intern_standard$feature_id, ], na.rm = TRUE)

cpt <- paste("Internal standards with detected and assigned features coefficient
             of variation before and after different method of normalization.")
pandoc.table(intern_standard[, c("abbreviation", "CV_raw", "CV_norm")],
             style = "rmarkdown", caption = cpt)
```
Some lower a little bit some increases a little bit..

Study samples
```{r include=TRUE, results = "asis"}
index_study <- res$phenotype %in% c("CTR", "CVD")

study_sample <- cbind(CV_Raw = rowRsd(assay(res, "raw_filled")[, index_study],
                                      na.rm = TRUE),
            CV_norm = rowRsd(assay(res, "norm")[, index_study], na.rm = TRUE)
)

#' Number <0.3
study_summary <- matrix(ncol= ncol(study_sample), dimnames = list("CV <0.3"))
for (i in seq_len(ncol(study_sample))){
    study_summary["CV <0.3",i] <- sum(study_sample[, i] < 0.3, na.rm = TRUE)
}
colnames(study_summary) <- colnames(study_sample)
study_summary

#' Quantile
study_df$norm <- quantile(study_sample[, "CV_norm"], na.rm = TRUE)
cpt <- paste0("Distribution of CV values across study samples for the raw ",
              "and between-sample normalized data.")
pandoc.table(study_df[c("raw", "norm")], style = "rmarkdown", caption = cpt)
```

Increases quite significantly i think...
